<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>XACC: CSimpleIniTempl&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt; Class Template Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">XACC </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00849.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CSimpleIniTempl&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00733_source.html">SimpleIni.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">Converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">Entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">FileWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">OutputWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00297.html">StringWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad7ffad7e87da2303a05b885e95bc74fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ffad7e87da2303a05b885e95bc74fa"></a>
typedef SI_CHAR&#160;</td><td class="memItemRight" valign="bottom"><b>SI_CHAR_T</b></td></tr>
<tr class="separator:ad7ffad7e87da2303a05b885e95bc74fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0e11d84617214bd479de6332c80e6"><td class="memItemLeft" align="right" valign="top">typedef std::multimap&lt; <a class="el" href="a00096.html">Entry</a>, const SI_CHAR *, typename <a class="el" href="a00189.html">Entry::KeyOrder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ae7f0e11d84617214bd479de6332c80e6">TKeyVal</a></td></tr>
<tr class="separator:ae7f0e11d84617214bd479de6332c80e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7963455f680abd0d6901786495a665"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="a00096.html">Entry</a>, <a class="el" href="a00069.html#ae7f0e11d84617214bd479de6332c80e6">TKeyVal</a>, typename <a class="el" href="a00189.html">Entry::KeyOrder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a2e7963455f680abd0d6901786495a665">TSection</a></td></tr>
<tr class="separator:a2e7963455f680abd0d6901786495a665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391b3f3751e06cd9e9de4fb16ac14342"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="a00096.html">Entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a></td></tr>
<tr class="separator:a391b3f3751e06cd9e9de4fb16ac14342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af878d0a2aa780255b621e95f58f691d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#af878d0a2aa780255b621e95f58f691d8">CSimpleIniTempl</a> (bool a_bIsUtf8=false, bool a_bMultiKey=false, bool a_bMultiLine=false)</td></tr>
<tr class="separator:af878d0a2aa780255b621e95f58f691d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c933adc1d46bb663caeb6f9dee5aa12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a8c933adc1d46bb663caeb6f9dee5aa12">~CSimpleIniTempl</a> ()</td></tr>
<tr class="separator:a8c933adc1d46bb663caeb6f9dee5aa12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b34d38be4518e9ed91c634a41b8055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a89b34d38be4518e9ed91c634a41b8055">Reset</a> ()</td></tr>
<tr class="separator:a89b34d38be4518e9ed91c634a41b8055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaada2b1ab734fc7dd8780ba7f376c26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#acaada2b1ab734fc7dd8780ba7f376c26">IsEmpty</a> () const </td></tr>
<tr class="separator:acaada2b1ab734fc7dd8780ba7f376c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb6e5fff76efc05ca6cc4b7b56481a3"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aebb6e5fff76efc05ca6cc4b7b56481a3">LoadFile</a> (const char *a_pszFile)</td></tr>
<tr class="separator:aebb6e5fff76efc05ca6cc4b7b56481a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccb65e82fa347b42b59330968f826ae"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a7ccb65e82fa347b42b59330968f826ae">LoadFile</a> (FILE *a_fpFile)</td></tr>
<tr class="separator:a7ccb65e82fa347b42b59330968f826ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174244fd3e09ff78da05fe46be86e714"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a174244fd3e09ff78da05fe46be86e714">LoadData</a> (const std::string &amp;a_strData)</td></tr>
<tr class="separator:a174244fd3e09ff78da05fe46be86e714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa797cf47cec05906f07d5065882af4d3"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aa797cf47cec05906f07d5065882af4d3">LoadData</a> (const char *a_pData, size_t a_uDataLen)</td></tr>
<tr class="separator:aa797cf47cec05906f07d5065882af4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1449e083d968790ef7479de24edddba0"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a1449e083d968790ef7479de24edddba0">SaveFile</a> (const char *a_pszFile, bool a_bAddSignature=true) const </td></tr>
<tr class="separator:a1449e083d968790ef7479de24edddba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f26b331a0f9d7f071d7b4aa8038758"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#af3f26b331a0f9d7f071d7b4aa8038758">SaveFile</a> (FILE *a_pFile, bool a_bAddSignature=false) const </td></tr>
<tr class="separator:af3f26b331a0f9d7f071d7b4aa8038758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea5d590edbb5eef694991c7c355915"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a5fea5d590edbb5eef694991c7c355915">Save</a> (<a class="el" href="a00229.html">OutputWriter</a> &amp;a_oOutput, bool a_bAddSignature=false) const </td></tr>
<tr class="separator:a5fea5d590edbb5eef694991c7c355915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944674fb44473ede150a3bcdc103d63"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#af944674fb44473ede150a3bcdc103d63">Save</a> (std::string &amp;a_sBuffer, bool a_bAddSignature=false) const </td></tr>
<tr class="separator:af944674fb44473ede150a3bcdc103d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b01b5bf88d0dfe3ba51f12278cbcb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a65b01b5bf88d0dfe3ba51f12278cbcb8">GetAllSections</a> (<a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a> &amp;a_names) const </td></tr>
<tr class="separator:a65b01b5bf88d0dfe3ba51f12278cbcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf1357d78d28653b68790ab5d5b45f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a8cf1357d78d28653b68790ab5d5b45f1">GetAllKeys</a> (const SI_CHAR *a_pSection, <a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a> &amp;a_names) const </td></tr>
<tr class="separator:a8cf1357d78d28653b68790ab5d5b45f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263c85a8cd839c315fefc078e048257b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a263c85a8cd839c315fefc078e048257b">GetAllValues</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, <a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a> &amp;a_values) const </td></tr>
<tr class="separator:a263c85a8cd839c315fefc078e048257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e612d67d1e1631c157af6291ac8c348"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a2e612d67d1e1631c157af6291ac8c348">GetSectionSize</a> (const SI_CHAR *a_pSection) const </td></tr>
<tr class="separator:a2e612d67d1e1631c157af6291ac8c348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795e2fcbad3472055aedfe188f4f8d33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00069.html#ae7f0e11d84617214bd479de6332c80e6">TKeyVal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a795e2fcbad3472055aedfe188f4f8d33">GetSection</a> (const SI_CHAR *a_pSection) const </td></tr>
<tr class="separator:a795e2fcbad3472055aedfe188f4f8d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39999339113e9395d5e2c6b02ef5c618"><td class="memItemLeft" align="right" valign="top">const SI_CHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a39999339113e9395d5e2c6b02ef5c618">GetValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, const SI_CHAR *a_pDefault=NULL, bool *a_pHasMultiple=NULL) const </td></tr>
<tr class="separator:a39999339113e9395d5e2c6b02ef5c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994c6b29bb8b4c16a4b1a7f4c8b2b3f4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a994c6b29bb8b4c16a4b1a7f4c8b2b3f4">GetLongValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, long a_nDefault=0, bool *a_pHasMultiple=NULL) const </td></tr>
<tr class="separator:a994c6b29bb8b4c16a4b1a7f4c8b2b3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce7c77a1d5d64dc289927a5c2659e78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a6ce7c77a1d5d64dc289927a5c2659e78">GetDoubleValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, double a_nDefault=0, bool *a_pHasMultiple=NULL) const </td></tr>
<tr class="separator:a6ce7c77a1d5d64dc289927a5c2659e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a8cffb0b7f6ca04e3eed9ab4660666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#af0a8cffb0b7f6ca04e3eed9ab4660666">GetBoolValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, bool a_bDefault=false, bool *a_pHasMultiple=NULL) const </td></tr>
<tr class="separator:af0a8cffb0b7f6ca04e3eed9ab4660666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2014a3dc8fdd638316cf1d3611796ab"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aa2014a3dc8fdd638316cf1d3611796ab">SetValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, const SI_CHAR *a_pValue, const SI_CHAR *a_pComment=NULL, bool a_bForceReplace=false)</td></tr>
<tr class="separator:aa2014a3dc8fdd638316cf1d3611796ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2238be407232e4bba0f1343e4793e4e"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ab2238be407232e4bba0f1343e4793e4e">SetLongValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, long a_nValue, const SI_CHAR *a_pComment=NULL, bool a_bUseHex=false, bool a_bForceReplace=false)</td></tr>
<tr class="separator:ab2238be407232e4bba0f1343e4793e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92ba0b8067553ab693c62a370de6534"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#af92ba0b8067553ab693c62a370de6534">SetDoubleValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, double a_nValue, const SI_CHAR *a_pComment=NULL, bool a_bForceReplace=false)</td></tr>
<tr class="separator:af92ba0b8067553ab693c62a370de6534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ae136fa20c5d7eb7ab0b75342b27cf"><td class="memItemLeft" align="right" valign="top">SI_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a48ae136fa20c5d7eb7ab0b75342b27cf">SetBoolValue</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, bool a_bValue, const SI_CHAR *a_pComment=NULL, bool a_bForceReplace=false)</td></tr>
<tr class="separator:a48ae136fa20c5d7eb7ab0b75342b27cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c1cdd0b306434d9e9f1422888049da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aa5c1cdd0b306434d9e9f1422888049da">Delete</a> (const SI_CHAR *a_pSection, const SI_CHAR *a_pKey, bool a_bRemoveEmpty=false)</td></tr>
<tr class="separator:aa5c1cdd0b306434d9e9f1422888049da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98442d01db35187f2770f0a91042cce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00066.html">Converter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a98442d01db35187f2770f0a91042cce8">GetConverter</a> () const </td></tr>
<tr class="separator:a98442d01db35187f2770f0a91042cce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Settings</div></td></tr>
<tr class="memitem:aa9a15a66de893571014f661f89cb4d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aa9a15a66de893571014f661f89cb4d4b">SetUnicode</a> (bool a_bIsUtf8=true)</td></tr>
<tr class="separator:aa9a15a66de893571014f661f89cb4d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18f29d67107392a9e9f361def892c71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aa18f29d67107392a9e9f361def892c71">IsUnicode</a> () const </td></tr>
<tr class="separator:aa18f29d67107392a9e9f361def892c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cfaf072a64f960bdcb7ddf2edc52b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ac3cfaf072a64f960bdcb7ddf2edc52b6">SetMultiKey</a> (bool a_bAllowMultiKey=true)</td></tr>
<tr class="separator:ac3cfaf072a64f960bdcb7ddf2edc52b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8069b3c574949b78fe0274ae803f0685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a8069b3c574949b78fe0274ae803f0685">IsMultiKey</a> () const </td></tr>
<tr class="separator:a8069b3c574949b78fe0274ae803f0685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7214b76600790053a5c715e9730aab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#aa7214b76600790053a5c715e9730aab0">SetMultiLine</a> (bool a_bAllowMultiLine=true)</td></tr>
<tr class="separator:aa7214b76600790053a5c715e9730aab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805dba3689efd63f8c4485a5f2e89090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a805dba3689efd63f8c4485a5f2e89090">IsMultiLine</a> () const </td></tr>
<tr class="separator:a805dba3689efd63f8c4485a5f2e89090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c0eae2dcd84a42c99bb86ae103662c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#ae3c0eae2dcd84a42c99bb86ae103662c">SetSpaces</a> (bool a_bSpaces=true)</td></tr>
<tr class="separator:ae3c0eae2dcd84a42c99bb86ae103662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c967faf796cf5babea67e97975bed9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html#a9c967faf796cf5babea67e97975bed9b">UsingSpaces</a> () const </td></tr>
<tr class="separator:a9c967faf796cf5babea67e97975bed9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SI_CHAR, class SI_STRLESS, class SI_CONVERTER&gt;<br />
class CSimpleIniTempl&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;</h3>

<p>Simple INI file reader.</p>
<p>This can be instantiated with the choice of unicode or native characterset, and case sensitive or insensitive comparisons of section and key names. The supported combinations are pre-defined with the following typedefs:</p>
<table class="doxtable">
<tr>
<th>Interface </th><th>Case-sensitive </th><th>Typedef </th></tr>
<tr>
<td>char </td><td>No </td><td>CSimpleIniA </td></tr>
<tr>
<td>char </td><td>Yes </td><td>CSimpleIniCaseA </td></tr>
<tr>
<td>wchar_t </td><td>No </td><td>CSimpleIniW </td></tr>
<tr>
<td>wchar_t </td><td>Yes </td><td>CSimpleIniCaseW </td></tr>
</table>
<p>Note that using other types for the SI_CHAR is supported. For instance, unsigned char, unsigned short, etc. Note that where the alternative type is a different size to char/wchar_t you may need to supply new helper classes for SI_STRLESS and SI_CONVERTER. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae7f0e11d84617214bd479de6332c80e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::multimap&lt;<a class="el" href="a00096.html">Entry</a>,const SI_CHAR *,typename <a class="el" href="a00189.html">Entry::KeyOrder</a>&gt; <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::<a class="el" href="a00069.html#ae7f0e11d84617214bd479de6332c80e6">TKeyVal</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>map keys to values </p>

</div>
</div>
<a class="anchor" id="a391b3f3751e06cd9e9de4fb16ac14342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="a00096.html">Entry</a>&gt; <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::<a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set of dependent string pointers. Note that these pointers are dependent on memory owned by CSimpleIni. </p>

</div>
</div>
<a class="anchor" id="a2e7963455f680abd0d6901786495a665"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="a00096.html">Entry</a>,<a class="el" href="a00069.html#ae7f0e11d84617214bd479de6332c80e6">TKeyVal</a>,typename <a class="el" href="a00189.html">Entry::KeyOrder</a>&gt; <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::<a class="el" href="a00069.html#a2e7963455f680abd0d6901786495a665">TSection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>map sections to key/value map </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af878d0a2aa780255b621e95f58f691d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::<a class="el" href="a00069.html">CSimpleIniTempl</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bIsUtf8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bMultiKey</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bMultiLine</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_bIsUtf8</td><td>See the method <a class="el" href="a00069.html#aa9a15a66de893571014f661f89cb4d4b">SetUnicode()</a> for details. </td></tr>
    <tr><td class="paramname">a_bMultiKey</td><td>See the method <a class="el" href="a00069.html#ac3cfaf072a64f960bdcb7ddf2edc52b6">SetMultiKey()</a> for details. </td></tr>
    <tr><td class="paramname">a_bMultiLine</td><td>See the method <a class="el" href="a00069.html#aa7214b76600790053a5c715e9730aab0">SetMultiLine()</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c933adc1d46bb663caeb6f9dee5aa12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::~<a class="el" href="a00069.html">CSimpleIniTempl</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa5c1cdd0b306434d9e9f1422888049da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::Delete </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bRemoveEmpty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete an entire section, or a key from a section. Note that the data returned by GetSection is invalid and must not be used after anything has been deleted from that section using this method. Note when multiple keys is enabled, this will delete all keys with that name; there is no way to selectively delete individual key/values in this situation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to delete key from, or if a_pKey is NULL, the section to remove. </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to remove from the section. Set to NULL to remove the entire section. </td></tr>
    <tr><td class="paramname">a_bRemoveEmpty</td><td>If the section is empty after this key has been deleted, should the empty section be removed?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Key or section was deleted. </dd>
<dd>
false Key or section was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cf1357d78d28653b68790ab5d5b45f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetAllKeys </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a> &amp;&#160;</td>
          <td class="paramname"><em>a_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve all unique key names in a section. The sort order of the returned strings is NOT DEFINED. You can sort the names into the load order if desired. Search this file for ".sort" for an example. Only unique key names are returned.</p>
<p>NOTE! This structure contains only pointers to strings. The actual string data is stored in memory owned by CSimpleIni. Ensure that the CSimpleIni object is not destroyed or <a class="el" href="a00069.html#a89b34d38be4518e9ed91c634a41b8055">Reset()</a> while these strings are in use!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to request data for </td></tr>
    <tr><td class="paramname">a_names</td><td>List that will receive all of the key names. See note above!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Section was found. </dd>
<dd>
false Matching section was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a65b01b5bf88d0dfe3ba51f12278cbcb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetAllSections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a> &amp;&#160;</td>
          <td class="paramname"><em>a_names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve all section names. The list is returned as an STL vector of names and can be iterated or searched as necessary. Note that the sort order of the returned strings is NOT DEFINED. You can sort the names into the load order if desired. Search this file for ".sort" for an example.</p>
<p>NOTE! This structure contains only pointers to strings. The actual string data is stored in memory owned by CSimpleIni. Ensure that the CSimpleIni object is not destroyed or <a class="el" href="a00069.html#a89b34d38be4518e9ed91c634a41b8055">Reset()</a> while these pointers are in use!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_names</td><td>Vector that will receive all of the section names. See note above! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a263c85a8cd839c315fefc078e048257b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetAllValues </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00069.html#a391b3f3751e06cd9e9de4fb16ac14342">TNamesDepend</a> &amp;&#160;</td>
          <td class="paramname"><em>a_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve all values for a specific key. This method can be used when multiple keys are both enabled and disabled. Note that the sort order of the returned strings is NOT DEFINED. You can sort the names into the load order if desired. Search this file for ".sort" for an example.</p>
<p>NOTE! The returned values are pointers to string data stored in memory owned by CSimpleIni. Ensure that the CSimpleIni object is not destroyed or Reset while you are using this pointer!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to search </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to search for </td></tr>
    <tr><td class="paramname">a_values</td><td>List to return if the key is not found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Key was found. </dd>
<dd>
false Matching section/key was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="af0a8cffb0b7f6ca04e3eed9ab4660666"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetBoolValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bDefault</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>a_pHasMultiple</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a boolean value for a specific key. If multiple keys are enabled (see SetMultiKey) then only the first value associated with that key will be returned, see GetAllValues for getting all values with multikey.</p>
<p>Strings starting with "t", "y", "on" or "1" are returned as logically true. Strings starting with "f", "n", "of" or "0" are returned as logically false. For all other values the default is returned. Character comparisons are case-insensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to search </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to search for </td></tr>
    <tr><td class="paramname">a_bDefault</td><td>Value to return if the key is not found </td></tr>
    <tr><td class="paramname">a_pHasMultiple</td><td>Optionally receive notification of if there are multiple entries for this key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a_nDefault Key was not found in the section </dd>
<dd>
other Value of the key </dd></dl>

</div>
</div>
<a class="anchor" id="a98442d01db35187f2770f0a91042cce8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00066.html">Converter</a> <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a conversion object to convert text to the same encoding as is used by the <a class="el" href="a00069.html#a5fea5d590edbb5eef694991c7c355915">Save()</a>, <a class="el" href="a00069.html#a1449e083d968790ef7479de24edddba0">SaveFile()</a> and SaveString() functions. Use this to prepare the strings that you wish to append or prepend to the output INI data. </p>

</div>
</div>
<a class="anchor" id="a6ce7c77a1d5d64dc289927a5c2659e78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetDoubleValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_nDefault</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>a_pHasMultiple</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a numeric value for a specific key. If multiple keys are enabled (see SetMultiKey) then only the first value associated with that key will be returned, see GetAllValues for getting all values with multikey.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to search </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to search for </td></tr>
    <tr><td class="paramname">a_nDefault</td><td>Value to return if the key is not found </td></tr>
    <tr><td class="paramname">a_pHasMultiple</td><td>Optionally receive notification of if there are multiple entries for this key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a_nDefault Key was not found in the section </dd>
<dd>
other Value of the key </dd></dl>

</div>
</div>
<a class="anchor" id="a994c6b29bb8b4c16a4b1a7f4c8b2b3f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetLongValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a_nDefault</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>a_pHasMultiple</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a numeric value for a specific key. If multiple keys are enabled (see SetMultiKey) then only the first value associated with that key will be returned, see GetAllValues for getting all values with multikey.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to search </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to search for </td></tr>
    <tr><td class="paramname">a_nDefault</td><td>Value to return if the key is not found </td></tr>
    <tr><td class="paramname">a_pHasMultiple</td><td>Optionally receive notification of if there are multiple entries for this key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a_nDefault Key was not found in the section </dd>
<dd>
other Value of the key </dd></dl>

</div>
</div>
<a class="anchor" id="a795e2fcbad3472055aedfe188f4f8d33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::<a class="el" href="a00069.html#ae7f0e11d84617214bd479de6332c80e6">TKeyVal</a> * <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetSection </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve all key and value pairs for a section. The data is returned as a pointer to an STL map and can be iterated or searched as desired. Note that multiple entries for the same key may exist when multiple keys have been enabled.</p>
<p>NOTE! This structure contains only pointers to strings. The actual string data is stored in memory owned by CSimpleIni. Ensure that the CSimpleIni object is not destroyed or <a class="el" href="a00069.html#a89b34d38be4518e9ed91c634a41b8055">Reset()</a> while these strings are in use!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Name of the section to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean Was a section matching the supplied name found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e612d67d1e1631c157af6291ac8c348"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetSectionSize </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the number of keys in a specific section. Note that if multiple keys are enabled, then this value may be different to the number of keys returned by GetAllKeys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to request data for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 Section does not exist in the file </dd>
<dd>
&gt;=0 Number of keys in the section </dd></dl>

</div>
</div>
<a class="anchor" id="a39999339113e9395d5e2c6b02ef5c618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const SI_CHAR * <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::GetValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pDefault</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>a_pHasMultiple</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value for a specific key. If multiple keys are enabled (see SetMultiKey) then only the first value associated with that key will be returned, see GetAllValues for getting all values with multikey.</p>
<p>NOTE! The returned value is a pointer to string data stored in memory owned by CSimpleIni. Ensure that the CSimpleIni object is not destroyed or Reset while you are using this pointer!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to search </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to search for </td></tr>
    <tr><td class="paramname">a_pDefault</td><td>Value to return if the key is not found </td></tr>
    <tr><td class="paramname">a_pHasMultiple</td><td>Optionally receive notification of if there are multiple entries for this key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a_pDefault Key was not found in the section </dd>
<dd>
other Value of the key </dd></dl>

</div>
</div>
<a class="anchor" id="acaada2b1ab734fc7dd8780ba7f376c26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Has any data been loaded </p>

</div>
</div>
<a class="anchor" id="a8069b3c574949b78fe0274ae803f0685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::IsMultiKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the storage format of the INI data. </p>

</div>
</div>
<a class="anchor" id="a805dba3689efd63f8c4485a5f2e89090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::IsMultiLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the status of multi-line data </p>

</div>
</div>
<a class="anchor" id="aa18f29d67107392a9e9f361def892c71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::IsUnicode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the storage format of the INI data. </p>

</div>
</div>
<a class="anchor" id="a174244fd3e09ff78da05fe46be86e714"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::LoadData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a_strData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load INI file data direct from a std::string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_strData</td><td>Data to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="aa797cf47cec05906f07d5065882af4d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::LoadData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a_pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a_uDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load INI file data direct from memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pData</td><td>Data to be loaded </td></tr>
    <tr><td class="paramname">a_uDataLen</td><td>Length of the data in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="aebb6e5fff76efc05ca6cc4b7b56481a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::LoadFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a_pszFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an INI file from disk into memory</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pszFile</td><td>Path of the file to be loaded. This will be passed to fopen() and so must be a valid path for the current platform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="a7ccb65e82fa347b42b59330968f826ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::LoadFile </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>a_fpFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the file from a file pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_fpFile</td><td>Valid file pointer to read the file data from. The file will be read until end of file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="a89b34d38be4518e9ed91c634a41b8055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate all memory stored by this object </p>

</div>
</div>
<a class="anchor" id="a5fea5d590edbb5eef694991c7c355915"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00229.html">OutputWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>a_oOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bAddSignature</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the INI data. The data will be written to the output device in a format appropriate to the current data, selected by:</p>
<table class="doxtable">
<tr>
<th>SI_CHAR </th><th>FORMAT </th></tr>
<tr>
<td>char </td><td>same format as when loaded (MBCS or UTF-8) </td></tr>
<tr>
<td>wchar_t </td><td>UTF-8 </td></tr>
<tr>
<td>other </td><td>UTF-8 </td></tr>
</table>
<p>Note that comments from the original data is preserved as per the documentation on comments. The order of the sections and values from the original file will be preserved.</p>
<p>Any data prepended or appended to the output device must use the the same format (MBCS or UTF-8). You may use the <a class="el" href="a00069.html#a98442d01db35187f2770f0a91042cce8">GetConverter()</a> method to convert text to the correct format regardless of the output format being used by SimpleIni.</p>
<p>To add a BOM to UTF-8 data, write it out manually at the very beginning like is done in SaveFile when a_bUseBOM is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_oOutput</td><td>Output writer to write the data to.</td></tr>
    <tr><td class="paramname">a_bAddSignature</td><td>Prepend the UTF-8 BOM if the output data is in UTF-8 format. If it is not UTF-8 then this value is ignored. Do not set this to true if anything has already been written to the <a class="el" href="a00229.html">OutputWriter</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="af944674fb44473ede150a3bcdc103d63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::Save </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>a_sBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bAddSignature</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append the INI data to a string. See <a class="el" href="a00069.html#a5fea5d590edbb5eef694991c7c355915">Save()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_sBuffer</td><td>String to have the INI data appended to.</td></tr>
    <tr><td class="paramname">a_bAddSignature</td><td>Prepend the UTF-8 BOM if the output data is in UTF-8 format. If it is not UTF-8 then this value is ignored. Do not set this to true if anything has already been written to the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="a1449e083d968790ef7479de24edddba0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SaveFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a_pszFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bAddSignature</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save an INI file from memory to disk</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pszFile</td><td>Path of the file to be saved. This will be passed to fopen() and so must be a valid path for the current platform.</td></tr>
    <tr><td class="paramname">a_bAddSignature</td><td>Prepend the UTF-8 BOM if the output data is in UTF-8 format. If it is not UTF-8 then this parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="af3f26b331a0f9d7f071d7b4aa8038758"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SaveFile </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>a_pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bAddSignature</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the INI data to a file. See <a class="el" href="a00069.html#a5fea5d590edbb5eef694991c7c355915">Save()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pFile</td><td>Handle to a file. File should be opened for binary output.</td></tr>
    <tr><td class="paramname">a_bAddSignature</td><td>Prepend the UTF-8 BOM if the output data is in UTF-8 format. If it is not UTF-8 then this value is ignored. Do not set this to true if anything has already been written to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd></dl>

</div>
</div>
<a class="anchor" id="a48ae136fa20c5d7eb7ab0b75342b27cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetBoolValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pComment</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bForceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add or update a boolean value. This will always insert when multiple keys are enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to add or update </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to add or update. </td></tr>
    <tr><td class="paramname">a_bValue</td><td>Value to set. </td></tr>
    <tr><td class="paramname">a_pComment</td><td>Comment to be associated with the key. See the notes on <a class="el" href="a00069.html#aa2014a3dc8fdd638316cf1d3611796ab">SetValue()</a> for comments. </td></tr>
    <tr><td class="paramname">a_bForceReplace</td><td>Should all existing values in a multi-key INI file be replaced with this entry. This option has no effect if not using multi-key files. The difference between Delete/SetBoolValue and SetBoolValue with a_bForceReplace = true, is that the load order and comment will be preserved this way.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd>
<dd>
SI_UPDATED Value was updated </dd>
<dd>
SI_INSERTED Value was inserted </dd></dl>

</div>
</div>
<a class="anchor" id="af92ba0b8067553ab693c62a370de6534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetDoubleValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_nValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pComment</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bForceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add or update a double value. This will always insert when multiple keys are enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to add or update </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to add or update. </td></tr>
    <tr><td class="paramname">a_nValue</td><td>Value to set. </td></tr>
    <tr><td class="paramname">a_pComment</td><td>Comment to be associated with the key. See the notes on <a class="el" href="a00069.html#aa2014a3dc8fdd638316cf1d3611796ab">SetValue()</a> for comments. </td></tr>
    <tr><td class="paramname">a_bForceReplace</td><td>Should all existing values in a multi-key INI file be replaced with this entry. This option has no effect if not using multi-key files. The difference between Delete/SetDoubleValue and SetDoubleValue with a_bForceReplace = true, is that the load order and comment will be preserved this way.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd>
<dd>
SI_UPDATED Value was updated </dd>
<dd>
SI_INSERTED Value was inserted </dd></dl>

</div>
</div>
<a class="anchor" id="ab2238be407232e4bba0f1343e4793e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetLongValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a_nValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pComment</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bUseHex</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bForceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add or update a numeric value. This will always insert when multiple keys are enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to add or update </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to add or update. </td></tr>
    <tr><td class="paramname">a_nValue</td><td>Value to set. </td></tr>
    <tr><td class="paramname">a_pComment</td><td>Comment to be associated with the key. See the notes on <a class="el" href="a00069.html#aa2014a3dc8fdd638316cf1d3611796ab">SetValue()</a> for comments. </td></tr>
    <tr><td class="paramname">a_bUseHex</td><td>By default the value will be written to the file in decimal format. Set this to true to write it as hexadecimal. </td></tr>
    <tr><td class="paramname">a_bForceReplace</td><td>Should all existing values in a multi-key INI file be replaced with this entry. This option has no effect if not using multi-key files. The difference between Delete/SetLongValue and SetLongValue with a_bForceReplace = true, is that the load order and comment will be preserved this way.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd>
<dd>
SI_UPDATED Value was updated </dd>
<dd>
SI_INSERTED Value was inserted </dd></dl>

</div>
</div>
<a class="anchor" id="ac3cfaf072a64f960bdcb7ddf2edc52b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetMultiKey </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bAllowMultiKey</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Should multiple identical keys be permitted in the file. If set to false then the last value encountered will be used as the value of the key. If set to true, then all values will be available to be queried. For example, with the following input:</p>
<pre>
[section]
test=value1
test=value2
</pre><p>Then with SetMultiKey(true), both of the values "value1" and "value2" will be returned for the key test. If SetMultiKey(false) is used, then the value for "test" will only be "value2". This value may be changed at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_bAllowMultiKey</td><td>Allow multi-keys in the source? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7214b76600790053a5c715e9730aab0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetMultiLine </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bAllowMultiLine</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Should data values be permitted to span multiple lines in the file. If set to false then the multi-line construct &lt;&lt;&lt;TAG as a value will be returned as is instead of loading the data. This value may be changed at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_bAllowMultiLine</td><td>Allow multi-line values in the source? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3c0eae2dcd84a42c99bb86ae103662c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetSpaces </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bSpaces</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Should spaces be added around the equals sign when writing key/value pairs out. When true, the result will be "key = value". When false, the result will be "key=value". This value may be changed at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_bSpaces</td><td>Add spaces around the equals sign? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9a15a66de893571014f661f89cb4d4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetUnicode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bIsUtf8</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the storage format of the INI data. This affects both the loading and saving of the INI data using all of the Load/Save API functions. This value cannot be changed after any INI data has been loaded.</p>
<p>If the file is not set to Unicode (UTF-8), then the data encoding is assumed to be the OS native encoding. This encoding is the system locale on Linux/Unix and the legacy MBCS encoding on Windows NT/2K/XP. If the storage format is set to Unicode then the file will be loaded as UTF-8 encoded data regardless of the native file encoding. If SI_CHAR == char then all of the char* parameters take and return UTF-8 encoded data regardless of the system locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_bIsUtf8</td><td>Assume UTF-8 encoding for the source? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2014a3dc8fdd638316cf1d3611796ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SI_Error <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::SetValue </td>
          <td>(</td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pSection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SI_CHAR *&#160;</td>
          <td class="paramname"><em>a_pComment</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_bForceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add or update a section or value. This will always insert when multiple keys are enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_pSection</td><td>Section to add or update </td></tr>
    <tr><td class="paramname">a_pKey</td><td>Key to add or update. Set to NULL to create an empty section. </td></tr>
    <tr><td class="paramname">a_pValue</td><td>Value to set. Set to NULL to create an empty section. </td></tr>
    <tr><td class="paramname">a_pComment</td><td>Comment to be associated with the section or the key. If a_pKey is NULL then it will be associated with the section, otherwise the key. Note that a comment may be set ONLY when the section or key is first created (i.e. when this function returns the value SI_INSERTED). If you wish to create a section with a comment then you need to create the section separately to the key. The comment string must be in full comment form already (have a comment character starting every line). </td></tr>
    <tr><td class="paramname">a_bForceReplace</td><td>Should all existing values in a multi-key INI file be replaced with this entry. This option has no effect if not using multi-key files. The difference between Delete/SetValue and SetValue with a_bForceReplace = true, is that the load order and comment will be preserved this way.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SI_Error See error definitions </dd>
<dd>
SI_UPDATED Value was updated </dd>
<dd>
SI_INSERTED Value was inserted </dd></dl>

</div>
</div>
<a class="anchor" id="a9c967faf796cf5babea67e97975bed9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SI_CHAR , class SI_STRLESS , class SI_CONVERTER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00069.html">CSimpleIniTempl</a>&lt; SI_CHAR, SI_STRLESS, SI_CONVERTER &gt;::UsingSpaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the status of spaces output </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00733_source.html">SimpleIni.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
