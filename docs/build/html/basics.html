

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Basics &mdash; XACC 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Extensions" href="extensions.html" />
    <link rel="prev" title="Installation" href="install.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> XACC
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#accelerator-buffer">Accelerator Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intermediate-representation-kernels-and-compilers">Intermediate Representation, Kernels, and Compilers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#observable">Observable</a></li>
<li class="toctree-l2"><a class="reference internal" href="#accelerator">Accelerator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimizer">Optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xacc-qasm">xacc::qasm()</a></li>
<li class="toctree-l2"><a class="reference internal" href="#single-source-pythonic-programming">Single-source Pythonic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="#benchmarks">Benchmarks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chemistry">Chemistry</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-process-tomography">Quantum Process Tomography</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developers</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XACC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="basics">
<h1>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h1>
<p>Here we demonstrate leveraging the XACC framework for various
quantum-classical programming tasks. We provide examples in both
C++ and Python.</p>
<div class="section" id="accelerator-buffer">
<h2>Accelerator Buffer<a class="headerlink" href="#accelerator-buffer" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code> represents a register of qubits. Programmers allocate
this register of a certain size, and pass it by reference to all execution tasks.
These execution tasks are carried out by concrete instances of the <cite>Accelerator</cite>
interface, and these instances are responsible for persisting information to the
provided buffer reference. This ensures programmers have access to all execution results
and metadata upon execution completion.</p>
<p>Programmers can allocate a buffer through the <code class="docutils literal notranslate"><span class="pre">xacc::qalloc(const</span> <span class="pre">int</span> <span class="pre">n)</span></code> (<code class="docutils literal notranslate"><span class="pre">xacc.qalloc(int)</span></code> in Python) call.
After execution, measurement results can be queried as well as backend-specific
execution metadata. Below demonstrate some basic usage of the <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="c1">// Create program somehow... detailed later</span>
<span class="n">program</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm:ibmq_valencia&quot;</span><span class="p">);</span>
<span class="n">qpu</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">program</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getMeasurementCounts</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">fidelities</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;1q-gate-fidelities&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">expValZ</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getExpectationValueZ</span><span class="p">();</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="o">//</span> <span class="n">Create</span> <span class="n">program</span> <span class="n">somehow</span><span class="o">...</span> <span class="n">detailed</span> <span class="n">later</span>
<span class="n">program</span> <span class="o">=</span> <span class="o">...</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm:ibmq_valencia&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">8192</span><span class="p">})</span>
<span class="n">qpu</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getMeasurementCounts</span><span class="p">()</span>
<span class="n">fidelities</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="s1">&#39;1q-gate-fidelities&#39;</span><span class="p">]</span>
<span class="n">expValZ</span> <span class="o">=</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getExpectationValueZ</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="intermediate-representation-kernels-and-compilers">
<h2>Intermediate Representation, Kernels, and Compilers<a class="headerlink" href="#intermediate-representation-kernels-and-compilers" title="Permalink to this headline">¶</a></h2>
<p>Above we mentioned a <code class="docutils literal notranslate"><span class="pre">program</span></code> variable but did not detail how it was created. This instance
is represented in XACC as a <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code>. The creation of <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> and
<code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code> is demonstrated below. First, we create this instances via an
implementation of the <code class="docutils literal notranslate"><span class="pre">IRProvider</span></code>, specifically a 3 instruction circuit with one
parameterized <code class="docutils literal notranslate"><span class="pre">Ry</span></code> on a variable <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getIRProvider</span><span class="p">(</span><span class="s">&quot;quantum&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">program</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createComposite</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&quot;theta&quot;</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">ry</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;Ry&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;theta&quot;</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;CX&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
<span class="n">program</span><span class="o">-&gt;</span><span class="n">addInstructions</span><span class="p">({</span><span class="n">x</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">cx</span><span class="p">});</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getIRProvider</span><span class="p">(</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
<span class="n">program</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createComposite</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">])</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createInstruction</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ry</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createInstruction</span><span class="p">(</span><span class="s1">&#39;Ry&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">])</span>
<span class="n">cx</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createInstruction</span><span class="p">(</span><span class="s1">&#39;CX&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">program</span><span class="o">.</span><span class="n">addInstructions</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">ry</span><span class="p">,</span><span class="n">cx</span><span class="p">])</span>
</pre></div>
</div>
<p>We could also create IR through textual source code representations in a language
that is available to the framework. Availability here implies that there exists
a <code class="docutils literal notranslate"><span class="pre">Compiler</span></code> implementation for the language being used. <code class="docutils literal notranslate"><span class="pre">Compilers</span></code> take kernel
source strings and produce IR (one or many <code class="docutils literal notranslate"><span class="pre">CompositeInstructions</span></code>). Here we demonstrate
the same circuit as above, but using a Quil kernel</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">quil</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;quil&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">quil</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s">__qpu__ void ansatz(AcceleratorBuffer q, double x) {</span>
<span class="s">    X 0</span>
<span class="s">    Ry(x) 1</span>
<span class="s">    CX 1 0</span>
<span class="s">}</span>
<span class="s">__qpu__ void X0X1(AcceleratorBuffer q, double x) {</span>
<span class="s">    ansatz(q, x)</span>
<span class="s">    H 0</span>
<span class="s">    H 1</span>
<span class="s">    MEASURE 0 [0]</span>
<span class="s">    MEASURE 1 [1]</span>
<span class="s">}</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qpu</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;ansatz&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">x0x1</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;X0X1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm&#39;</span><span class="p">)</span>
<span class="n">quil</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;quil&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">quil</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">__qpu__ void ansatz(AcceleratorBuffer q, double x) {</span>
<span class="s1">    X 0</span>
<span class="s1">    Ry(x) 1</span>
<span class="s1">    CX 1 0</span>
<span class="s1">}</span>
<span class="s1">__qpu__ void X0X1(AcceleratorBuffer q, double x) {</span>
<span class="s1">    ansatz(q, x)</span>
<span class="s1">    H 0</span>
<span class="s1">    H 1</span>
<span class="s1">    MEASURE 0 [0]</span>
<span class="s1">    MEASURE 1 [1]</span>
<span class="s1">}</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">qpu</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposite</span><span class="p">(</span><span class="s1">&#39;ansatz&#39;</span><span class="p">)</span>
<span class="n">x0x1</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposite</span><span class="p">(</span><span class="s1">&#39;X0X1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">x0x1</span></code> is a <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code> that can be passed to <code class="docutils literal notranslate"><span class="pre">Accelerator::execute()</span></code> for
backend execution.</p>
<p>Next we demonstrate how one might leverate <code class="docutils literal notranslate"><span class="pre">IRTransformation</span></code> to perform general optimizations
on IR instances.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">xasmCompiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;xasm&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">xasmCompiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">__qpu__ void bell(qbit q) {</span>
<span class="s">    H(q[0]);</span>
<span class="s">    CX(q[0], q[1]);</span>
<span class="s">    CX(q[0], q[1]);</span>
<span class="s">    CX(q[0], q[1]);</span>
<span class="s">    Measure(q[0]);</span>
<span class="s">    Measure(q[1]);</span>
<span class="s">}</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;bell&quot;</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">nInstructions</span><span class="p">());</span>

<span class="k">auto</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getIRTransformation</span><span class="p">(</span><span class="s">&quot;circuit-optimizer&quot;</span><span class="p">);</span>
<span class="n">opt</span><span class="o">-&gt;</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>

<span class="n">assert</span> <span class="p">(</span><span class="mi">4</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">nInstructions</span><span class="p">());</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="c1"># Create a bell state program with too many cnots</span>
<span class="n">xasm</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;xasm&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">xasm</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;__qpu__ void bell(qbit q) {</span>
<span class="s1">H(q[0]);</span>
<span class="s1">CX(q[0],q[1]);</span>
<span class="s1">CX(q[0],q[1]);</span>
<span class="s1">CX(q[0], q[1]);</span>
<span class="s1">Measure(q[0]);</span>
<span class="s1">Measure(q[1]);</span>
<span class="s1">}&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposite</span><span class="p">(</span><span class="s1">&#39;bell&#39;</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nInstructions</span><span class="p">())</span>

<span class="c1"># Run the circuit-optimizer IRTransformation</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getIRTransformation</span><span class="p">(</span><span class="s1">&#39;circuit-optimizer&#39;</span><span class="p">)</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">{})</span>

<span class="c1"># should have 4 instructions, not 6</span>
<span class="k">assert</span><span class="p">(</span><span class="mi">4</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nInstructions</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="observable">
<h2>Observable<a class="headerlink" href="#observable" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Observable</span></code> concept in XACC dictates measurements to be performed
on unmeasured an <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code>. XACC provides <code class="docutils literal notranslate"><span class="pre">pauli</span></code> and <code class="docutils literal notranslate"><span class="pre">fermion</span></code>
<code class="docutils literal notranslate"><span class="pre">Observable</span></code> implementations. Below we demonstrate how one might create these objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;xacc.hpp&quot;
#include &quot;xacc_observable.hpp&quot;
...
auto x0x1 = xacc::quantum::getObservable(&quot;pauli&quot;);
x0x1-&gt;fromString(&#39;X0 X1&#39;);

// observe() returns a list of measured circuits
// here we only have one
auto measured_circuit = x0x1-&gt;observe(program)[0];

auto fermion = xacc::getObservable(&quot;fermion&quot;);
fermion-&gt;fromString(&quot;1^ 0&quot;);
auto jw = xacc::getService&lt;ObservableTransform&gt;(&quot;jordan-wigner&quot;);
auto spin = jw-&gt;transform(fermion);
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="n">x0x1</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;pauli&#39;</span><span class="p">,</span> <span class="s1">&#39;X0 X1&#39;</span><span class="p">)</span>

<span class="o">//</span> <span class="n">observe</span><span class="p">()</span> <span class="n">returns</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">measured</span> <span class="n">circuits</span>
<span class="o">//</span> <span class="n">here</span> <span class="n">we</span> <span class="n">only</span> <span class="n">have</span> <span class="n">one</span>
<span class="n">measured_circuit</span> <span class="o">=</span> <span class="n">x0x1</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">program</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fermion</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;fermion&#39;</span><span class="p">,</span> <span class="s1">&#39;1^ 0&#39;</span><span class="p">)</span>
<span class="n">jw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservableTransform</span><span class="p">(</span><span class="s1">&#39;jordan-wigner&#39;</span><span class="p">)</span>
<span class="n">spin</span> <span class="o">=</span> <span class="n">jw</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">fermion</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="accelerator">
<h2>Accelerator<a class="headerlink" href="#accelerator" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Accelerator</span></code> is the primary interface to backend quantum computers and simulators for XACC.
The can be initialized with a heterogeneous map of input parameters, expose qubit connectivity information,
and implement execution capabilities given a valid <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code>.
Here we demonstrate getting reference to an <code class="docutils literal notranslate"><span class="pre">Accelerator</span></code> and using it to execute a simple bell state.
Note this is a full example, that leverages the <code class="docutils literal notranslate"><span class="pre">xasm</span></code> compiler as well as requisite C++ framework
initialization and finalization.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="c1">// Get reference to the Accelerator</span>
  <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span>
    <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;local-ibm&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)});</span>

  <span class="c1">// Allocate some qubits</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">xasmCompiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;xasm&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">xasmCompiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">__qpu__ void bell(qbit q) {</span>
<span class="s">      H(q[0]);</span>
<span class="s">      CX(q[0], q[1]);</span>
<span class="s">      Measure(q[0]);</span>
<span class="s">      Measure(q[1]);</span>
<span class="s">  }</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">);</span>

  <span class="n">accelerator</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposites</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>

  <span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;local-ibm&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">5000</span><span class="p">})</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">xasm</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;xasm&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">xasm</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;__qpu__ void bell(qbit q) {</span>
<span class="s1">H(q[0]);</span>
<span class="s1">CX(q[0],q[1]);</span>
<span class="s1">Measure(q[0]);</span>
<span class="s1">Measure(q[1]);</span>
<span class="s1">}&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">)</span>

<span class="n">accelerator</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposites</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># note accelerators can execute lists of CompositeInstructions too</span>
<span class="c1"># usefule for executing many circuits with one remote qpu call</span>
<span class="c1"># accelerator.execute(buffer, ir.getComposites())</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizer">
<h2>Optimizer<a class="headerlink" href="#optimizer" title="Permalink to this headline">¶</a></h2>
<p>This abstraction is meant for the injection of general classical multi-variate function
optimization routines. XACC provides implementations leveraging NLOpt and MLPack C++ libraries.
<code class="docutils literal notranslate"><span class="pre">Optimizer``s</span> <span class="pre">expose</span> <span class="pre">an</span> <span class="pre">``optimize()</span></code> method that takes as input an <code class="docutils literal notranslate"><span class="pre">OptFunction</span></code>, which serves as
a thin wrapper for functor-like objects exposing a specific argument structure (must take as first
arg a <code class="docutils literal notranslate"><span class="pre">vector&lt;double&gt;</span></code> representing current iterate’s parameters, and another one representing the mutable
gradient vector). Below is a demonstration of how one might use this utility:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span>
   <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">);</span>

<span class="n">optimizer</span><span class="o">-&gt;</span><span class="n">setOptions</span><span class="p">(</span>
   <span class="n">HeterogeneousMap</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-maxeval&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-optimizer&quot;</span><span class="p">,</span> <span class="s">&quot;l-bfgs&quot;</span><span class="p">)});</span>
<span class="n">OptFunction</span> <span class="nf">f</span><span class="p">(</span>
   <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">grad</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grad</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
       <span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">400</span> <span class="o">*</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
       <span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">));</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
   <span class="p">},</span>
   <span class="mi">2</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">-&gt;</span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">opt_val</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">opt_params</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rosen_with_grad</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mf">400.</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">200</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">g</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;mlpack&#39;</span><span class="p">,{</span><span class="s1">&#39;mlpack-optimizer&#39;</span><span class="p">:</span><span class="s1">&#39;l-bfgs&#39;</span><span class="p">})</span>
<span class="n">opt_val</span><span class="p">,</span> <span class="n">opt_params</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">rosen_with_grad</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="xacc-qasm">
<h2>xacc::qasm()<a class="headerlink" href="#xacc-qasm" title="Permalink to this headline">¶</a></h2>
<p>To improve programming efficiency, readability, and utility of the quantum kernel string
compilation, XACC exposes a <code class="docutils literal notranslate"><span class="pre">qasm()</span></code> function. This function takes as input an enhanced quantum
kernel source string syntax and compiles it to XACC IR. This source string is <em>enhanced</em> in that
it requires that extra metadata be present in order to adequately compile the quantum code.
Specifically, the source string must contain the following key words:</p>
<ul class="simple">
<li><p>a single <em>.compiler NAME</em>, to indicate which XACC compiler implementation to use.</p></li>
<li><p>one or many <em>.circuit NAME</em> calls to give the created CompositeInstruction (circuit) a name.</p></li>
<li><p>one <em>.parameters PARAM 1, PARAM 2, .., PARAM N</em> for each parameterized circuit to tell the Compiler the names of the parameters.</p></li>
<li><p>A <em>.qbit NAME</em> optional keyword can be provided when the source code itself makes reference to the <code class="docutils literal notranslate"><span class="pre">qbit</span></code> or <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code></p></li>
</ul>
<p>Running this command with the appropriately provided keywords will compile the source string to XACC IR and store it an
internal compilation database (standard map of CompositeInstruction names to CompositeInstructions), and users
can get reference to the individual CompositeInstructions via an exposed <code class="docutils literal notranslate"><span class="pre">getCompiled()</span></code> XACC API call. The
code below demonstrates how one would use <code class="docutils literal notranslate"><span class="pre">qasm()</span></code> and its overall utility.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s">.compiler xasm</span>
<span class="s">.circuit deuteron_ansatz</span>
<span class="s">.parameters x</span>
<span class="s">.qbit q</span>
<span class="s">for (int i = 0; i &lt; 2; i++) {</span>
<span class="s">  H(q[0]);</span>
<span class="s">}</span>
<span class="s">exp_i_theta(q, x, {{&quot;pauli&quot;, &quot;X0 Y1 - Y0 X1&quot;}});</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;deuteron_ansatz&quot;</span><span class="p">);</span>

<span class="c1">// Quil example, multiple kernels</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">.compiler quil</span>
<span class="s">.circuit ansatz</span>
<span class="s">.parameters theta, phi</span>
<span class="s">X 0</span>
<span class="s">H 2</span>
<span class="s">CNOT 2 1</span>
<span class="s">CNOT 0 1</span>
<span class="s">Rz(theta) 0</span>
<span class="s">Ry(phi) 1</span>
<span class="s">H 0</span>
<span class="s">.circuit x0x1</span>
<span class="s">ansatz(theta, phi)</span>
<span class="s">H 0</span>
<span class="s">H 1</span>
<span class="s">MEASURE 0 [0]</span>
<span class="s">MEASURE 1 [1]</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">x0x1</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;x0x1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
 <span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">.compiler xasm</span>
<span class="s1">.circuit deuteron_ansatz</span>
<span class="s1">.parameters x</span>
<span class="s1">.qbit q</span>
<span class="s1">for (int i = 0; i &lt; 2; i++) {</span>
<span class="s1">  X(q[0]);</span>
<span class="s1">}</span>
<span class="s1">exp_i_theta(q, x, {{&quot;pauli&quot;, &quot;X0 Y1 - Y0 X1&quot;}});</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span>
 <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;deuteron_ansatz&#39;</span><span class="p">)</span>

<span class="c1"># Quil example, multiple kernels</span>
<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;.compiler quil</span>
<span class="s1">.circuit ansatz</span>
<span class="s1">.parameters theta, phi</span>
<span class="s1">X 0</span>
<span class="s1">H 2</span>
<span class="s1">CNOT 2 1</span>
<span class="s1">CNOT 0 1</span>
<span class="s1">Rz(theta) 0</span>
<span class="s1">Ry(phi) 1</span>
<span class="s1">H 0</span>
<span class="s1">.circuit x0x1</span>
<span class="s1">ansatz(theta, phi)</span>
<span class="s1">H 0</span>
<span class="s1">H 1</span>
<span class="s1">MEASURE 0 [0]</span>
<span class="s1">MEASURE 1 [1]</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">x0x1</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;x0x1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="single-source-pythonic-programming">
<h2>Single-source Pythonic Programming<a class="headerlink" href="#single-source-pythonic-programming" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="benchmarks">
<h2>Benchmarks<a class="headerlink" href="#benchmarks" title="Permalink to this headline">¶</a></h2>
<p>Since XACC provides a hardware-agnostic framework
for quantum-classical computing, it is well-suited
for the development of general benchmark tasks that run
on available backend quantum computers. XACC provides a
Pythonic benchmarking tool that enables users to define
benchmarks via an input file or python dictionary, and then
distribute those files to be executed on available backends.
Benchmarks can be low-level and hardware-specific, or high-level,
application-style benchmarks.</p>
<p>The suite is extensible in the benchmark itself, as well
as input data required for the benchmark.</p>
<p>All benchmarks can be defined as INI files. These files describe
named sections of key-value pairs. Each benchmark requires an
XACC section (for the definition of the backend accelerator, number of shots, etc.) and
a Benchmark section (specifying the benchmark name and algorithm).
Other sections are specified by the concrete benchmark sub-type.</p>
<div class="section" id="chemistry">
<h3>Chemistry<a class="headerlink" href="#chemistry" title="Permalink to this headline">¶</a></h3>
<p>This Benchmark implementation enables one to define an application-level
benchmark which attempts to compute the accuracy with which a given
quantum backend can compute the ground state energy of a specified
electronic structure computation. Below is an example of such a benchmark
input file</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>XACC<span class="o">]</span>
<span class="nv">accelerator</span> <span class="o">=</span> ibm:ibmq_johannesburg
<span class="nv">shots</span> <span class="o">=</span> <span class="m">1024</span>
<span class="nv">verbose</span> <span class="o">=</span> True

<span class="o">[</span>Decorators<span class="o">]</span>
<span class="nv">readout_error</span> <span class="o">=</span> True

<span class="o">[</span>Benchmark<span class="o">]</span>
<span class="nv">name</span> <span class="o">=</span> chemistry
<span class="nv">algorithm</span> <span class="o">=</span> vqe

<span class="o">[</span>Ansatz<span class="o">]</span>
<span class="nb">source</span> <span class="o">=</span> .compiler xasm
    .circuit ansatz2
    .parameters x
    .qbit q
    X<span class="o">(</span>q<span class="o">[</span><span class="m">0</span><span class="o">])</span><span class="p">;</span>
    X<span class="o">(</span>q<span class="o">[</span><span class="m">2</span><span class="o">])</span><span class="p">;</span>
    ucc1<span class="o">(</span>q, x<span class="o">[</span><span class="m">0</span><span class="o">])</span><span class="p">;</span>

<span class="o">[</span>Observable<span class="o">]</span>
<span class="nv">name</span> <span class="o">=</span> psi4
<span class="nv">basis</span> <span class="o">=</span> sto-3g
<span class="nv">geometry</span> <span class="o">=</span> <span class="m">0</span> <span class="m">1</span>
       Na  <span class="m">0</span>.000000   <span class="m">0</span>.0      <span class="m">0</span>.0
       H   <span class="m">0</span>.0        <span class="m">0</span>.0  <span class="m">1</span>.914388
       symmetry c1
<span class="nv">fo</span> <span class="o">=</span> <span class="o">[</span><span class="m">0</span>, <span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span>, <span class="m">10</span>, <span class="m">11</span>, <span class="m">12</span>, <span class="m">13</span>, <span class="m">14</span><span class="o">]</span>
<span class="nv">ao</span> <span class="o">=</span> <span class="o">[</span><span class="m">5</span>, <span class="m">9</span>, <span class="m">15</span>, <span class="m">19</span><span class="o">]</span>

<span class="o">[</span>Optimizer<span class="o">]</span>
<span class="nv">name</span> <span class="o">=</span> nlopt
nlopt-maxeval <span class="o">=</span> <span class="m">20</span>
</pre></div>
</div>
<p>Stepping, through this, we see the benchmark is to be executed
on the IBM Johannesburg backend, with 1024 shots. Next, we specify
what benchmark algorithm to run - the Chemistry benchmark using the VQE
algorithm. After that, this benchmark
enables one to specify any AcceleratorDecorators to be used, here we
turn on readout-error decoration to correct computed expectation values
with respact to measurement readout errors. Moving down the file, one now
specifies the specific state-preparation ansatz to be used for this VQE
run, using the usual XACC qasm() format. Finally, we specify the Observable
we are interested in studying, and the classical optimizer to be used in
searching for the optimal expecation value for that observable.</p>
<p>One can run this benchmark with the following command (presuming it is in a
file named chem_nah_vqe_ibm.ini)</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 -m xacc --benchmark chem_nah_vqe_ibm.ini
</pre></div>
</div>
</div>
<div class="section" id="quantum-process-tomography">
<h3>Quantum Process Tomography<a class="headerlink" href="#quantum-process-tomography" title="Permalink to this headline">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>XACC<span class="o">]</span>
<span class="nv">accelerator</span> <span class="o">=</span> ibm:ibmq_poughkeepsie
<span class="nv">verbose</span> <span class="o">=</span> True

<span class="o">[</span>Benchmark<span class="o">]</span>
<span class="nv">name</span> <span class="o">=</span> qpt
<span class="nv">analysis</span> <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;fidelity&#39;</span>, <span class="s1">&#39;heat-maps&#39;</span><span class="o">]</span>
chi-theoretical-real <span class="o">=</span> <span class="o">[</span><span class="m">0</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">1</span>., <span class="m">0</span>., <span class="m">1</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">0</span>., <span class="m">1</span>., <span class="m">0</span>., <span class="m">1</span>.<span class="o">]</span>

<span class="o">[</span>Circuit<span class="o">]</span>
<span class="c1"># Logical circuit source code</span>
<span class="nb">source</span> <span class="o">=</span> .compiler xasm
    .circuit hadamard
    .qbit q
    H<span class="o">(</span>q<span class="o">[</span><span class="m">0</span><span class="o">])</span><span class="p">;</span>

<span class="c1"># Can specify physical qubit to run on</span>
qubit-map <span class="o">=</span> <span class="o">[</span><span class="m">1</span><span class="o">]</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extensions.html" class="btn btn-neutral float-right" title="Extensions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Alex McCaskey

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>