

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>XACC Basics &mdash; XACC 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Extensions" href="extensions.html" />
    <link rel="prev" title="Installation" href="install.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> XACC
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">XACC Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#acceleratorbuffer"><code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#intermediate-representation-kernels-and-compilers">Intermediate Representation, Kernels, and Compilers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#observable"><code class="docutils literal notranslate"><span class="pre">Observable</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#accelerator"><code class="docutils literal notranslate"><span class="pre">Accelerator</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimizer"><code class="docutils literal notranslate"><span class="pre">Optimizer</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#xacc-qasm"><code class="docutils literal notranslate"><span class="pre">xacc::qasm</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensions.html">Extensions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XACC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>XACC Basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xacc-basics">
<h1>XACC Basics<a class="headerlink" href="#xacc-basics" title="Permalink to this headline">¶</a></h1>
<p>Here we demonstrate leveraging the XACC framework for various
quantum-classical programming tasks. We provide examples in both
C++ and Python.</p>
<div class="section" id="acceleratorbuffer">
<h2><code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code><a class="headerlink" href="#acceleratorbuffer" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code> represents a register of qubits. Programmers allocate
this register of a certain size, and pass it by reference to all execution tasks.
These execution tasks are carried out by concrete instances of the <cite>Accelerator</cite>
interface, and these instances are responsible for persisting information to the
provided buffer reference. This ensures programmers have access to all execution results
and metadata upon execution completion.</p>
<p>Programmers can allocate a buffer through the <code class="docutils literal notranslate"><span class="pre">xacc::qalloc(const</span> <span class="pre">int</span> <span class="pre">n)</span></code> (<code class="docutils literal notranslate"><span class="pre">xacc.qalloc(int)</span></code> in Python) call.
After execution, measurement results can be queried as well as backend-specific
execution metadata. Below demonstrate some basic usage of the <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="c1">// Create program somehow... detailed later</span>
<span class="n">program</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm:ibmq_valencia&quot;</span><span class="p">);</span>
<span class="n">qpu</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">program</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getMeasurementCounts</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">fidelities</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="s">&quot;1q-gate-fidelities&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">expValZ</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">getExpectationValueZ</span><span class="p">();</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="o">//</span> <span class="n">Create</span> <span class="n">program</span> <span class="n">somehow</span><span class="o">...</span> <span class="n">detailed</span> <span class="n">later</span>
<span class="n">program</span> <span class="o">=</span> <span class="o">...</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm:ibmq_valencia&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">8192</span><span class="p">})</span>
<span class="n">qpu</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getMeasurementCounts</span><span class="p">()</span>
<span class="n">fidelities</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="s1">&#39;1q-gate-fidelities&#39;</span><span class="p">]</span>
<span class="n">expValZ</span> <span class="o">=</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getExpectationValueZ</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="intermediate-representation-kernels-and-compilers">
<h2>Intermediate Representation, Kernels, and Compilers<a class="headerlink" href="#intermediate-representation-kernels-and-compilers" title="Permalink to this headline">¶</a></h2>
<p>Above we mentioned a <code class="docutils literal notranslate"><span class="pre">program</span></code> variable but did not detail how it was created. This instances
is represented in XACC as a <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code>. The creation of <code class="docutils literal notranslate"><span class="pre">Instructions</span></code> and
<code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code> is demonstrated here. First, we create this instances via an
implementation of the <code class="docutils literal notranslate"><span class="pre">IRProvider</span></code>, specifically a 3 instruction circuit with one
parameterized <code class="docutils literal notranslate"><span class="pre">Ry</span></code> on a variable <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getIRProvider</span><span class="p">(</span><span class="s">&quot;quantum&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">program</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createComposite</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&quot;theta&quot;</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">ry</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;Ry&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;theta&quot;</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">provider</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;CX&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
<span class="n">program</span><span class="o">-&gt;</span><span class="n">addInstructions</span><span class="p">({</span><span class="n">x</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">cx</span><span class="p">});</span>
</pre></div>
</div>
<p>in Python</p>
<p>We could also create IR through textual source code representations in a language
that is available to the framework. Availability here implies that there exists
a <code class="docutils literal notranslate"><span class="pre">Compiler</span></code> implementation for the language being used. <code class="docutils literal notranslate"><span class="pre">Compilers</span></code> take kernel
source strings and produce IR (one or many <code class="docutils literal notranslate"><span class="pre">CompositeInstructions</span></code>). Here we demonstrate
the same circuit as above, but using a Quil kernel</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">quil</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;quil&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">quil</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s">__qpu__ void ansatz(AcceleratorBuffer q, double x) {</span>
<span class="s">    X 0</span>
<span class="s">    Ry(x) 1</span>
<span class="s">    CX 1 0</span>
<span class="s">}</span>
<span class="s">__qpu__ void X0X1(AcceleratorBuffer q, double x) {</span>
<span class="s">    ansatz(q, x)</span>
<span class="s">    H 0</span>
<span class="s">    H 1</span>
<span class="s">    MEASURE 0 [0]</span>
<span class="s">    MEASURE 1 [1]</span>
<span class="s">}</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qpu</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;ansatz&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">x0x1</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;X0X1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm&#39;</span><span class="p">)</span>
<span class="n">quil</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;quil&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">quil</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">__qpu__ void ansatz(AcceleratorBuffer q, double x) {</span>
<span class="s1">    X 0</span>
<span class="s1">    Ry(x) 1</span>
<span class="s1">    CX 1 0</span>
<span class="s1">}</span>
<span class="s1">__qpu__ void X0X1(AcceleratorBuffer q, double x) {</span>
<span class="s1">    ansatz(q, x)</span>
<span class="s1">    H 0</span>
<span class="s1">    H 1</span>
<span class="s1">    MEASURE 0 [0]</span>
<span class="s1">    MEASURE 1 [1]</span>
<span class="s1">}</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">qpu</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposite</span><span class="p">(</span><span class="s1">&#39;ansatz&#39;</span><span class="p">)</span>
<span class="n">x0x1</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposite</span><span class="p">(</span><span class="s1">&#39;X0X1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">x0x1</span></code> is a <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code> that can be passed to <code class="docutils literal notranslate"><span class="pre">Accelerator::execute()</span></code> for
backend execution.</p>
<p>Next we demonstrate how one might leverate <code class="docutils literal notranslate"><span class="pre">IRTransformation</span></code> to perform general optimizations
on IR instances.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">xasmCompiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;xasm&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">xasmCompiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">__qpu__ void bell(qbit q) {</span>
<span class="s">    H(q[0]);</span>
<span class="s">    CX(q[0], q[1]);</span>
<span class="s">    CX(q[0], q[1]);</span>
<span class="s">    CX(q[0], q[1]);</span>
<span class="s">    Measure(q[0]);</span>
<span class="s">    Measure(q[1]);</span>
<span class="s">}</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;bell&quot;</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">nInstructions</span><span class="p">());</span>

<span class="k">auto</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getIRTransformation</span><span class="p">(</span><span class="s">&quot;circuit-optimizer&quot;</span><span class="p">);</span>
<span class="n">opt</span><span class="o">-&gt;</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>

<span class="n">assert</span> <span class="p">(</span><span class="mi">4</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">nInstructions</span><span class="p">());</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="c1"># Create a bell state program with too many cnots</span>
<span class="n">xasm</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;xasm&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">xasm</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;__qpu__ void bell(qbit q) {</span>
<span class="s1">H(q[0]);</span>
<span class="s1">CX(q[0],q[1]);</span>
<span class="s1">CX(q[0],q[1]);</span>
<span class="s1">CX(q[0], q[1]);</span>
<span class="s1">Measure(q[0]);</span>
<span class="s1">Measure(q[1]);</span>
<span class="s1">}&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposite</span><span class="p">(</span><span class="s1">&#39;bell&#39;</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nInstructions</span><span class="p">())</span>

<span class="c1"># Run the circuit-optimizer IRTransformation</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getIRTransformation</span><span class="p">(</span><span class="s1">&#39;circuit-optimizer&#39;</span><span class="p">)</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">{})</span>

<span class="c1"># should have 4 instructions, not 6</span>
<span class="k">assert</span><span class="p">(</span><span class="mi">4</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nInstructions</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="observable">
<h2><code class="docutils literal notranslate"><span class="pre">Observable</span></code><a class="headerlink" href="#observable" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Observable</span></code> concept in XACC dictates measurements to be performed
on unmeasured an <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code>. XACC provides <code class="docutils literal notranslate"><span class="pre">pauli</span></code> and <code class="docutils literal notranslate"><span class="pre">fermion</span></code>
<code class="docutils literal notranslate"><span class="pre">Observable</span></code> implementations. Below we demonstrate how one might create these objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;xacc.hpp&quot;
#include &quot;xacc_observable.hpp&quot;
...
auto x0x1 = xacc::quantum::getObservable(&quot;pauli&quot;);
x0x1-&gt;fromString(&#39;X0 X1&#39;);

// observe() returns a list of measured circuits
// here we only have one
auto measured_circuit = x0x1-&gt;observe(program)[0];

auto fermion = xacc::getObservable(&quot;fermion&quot;);
fermion-&gt;fromString(&quot;1^ 0&quot;);
auto jw = xacc::getService&lt;ObservableTransform&gt;(&quot;jordan-wigner&quot;);
auto spin = jw-&gt;transform(fermion);
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
<span class="n">x0x1</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;pauli&#39;</span><span class="p">,</span> <span class="s1">&#39;X0 X1&#39;</span><span class="p">)</span>

<span class="o">//</span> <span class="n">observe</span><span class="p">()</span> <span class="n">returns</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">measured</span> <span class="n">circuits</span>
<span class="o">//</span> <span class="n">here</span> <span class="n">we</span> <span class="n">only</span> <span class="n">have</span> <span class="n">one</span>
<span class="n">measured_circuit</span> <span class="o">=</span> <span class="n">x0x1</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">program</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">fermion</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;fermion&#39;</span><span class="p">,</span> <span class="s1">&#39;1^ 0&#39;</span><span class="p">)</span>
<span class="n">jw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservableTransform</span><span class="p">(</span><span class="s1">&#39;jordan-wigner&#39;</span><span class="p">)</span>
<span class="n">spin</span> <span class="o">=</span> <span class="n">jw</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">fermion</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="accelerator">
<h2><code class="docutils literal notranslate"><span class="pre">Accelerator</span></code><a class="headerlink" href="#accelerator" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Accelerator</span></code> is the primary interface to backend quantum computers and simulators for XACC.
The can be initialized with a heterogeneous map of input parameters, expose qubit connectivity information,
and implement execution capabilities given a valid <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code>.
Here we demonstrate getting reference to an <code class="docutils literal notranslate"><span class="pre">Accelerator</span></code> and using it to execute a simple bell state.
Note this is a full example, that leverages the <code class="docutils literal notranslate"><span class="pre">xasm</span></code> compiler as well as requisite C++ framework
initialization and finalization.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="c1">// Get reference to the Accelerator</span>
  <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span>
    <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;local-ibm&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)});</span>

  <span class="c1">// Allocate some qubits</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">xasmCompiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;xasm&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">xasmCompiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">__qpu__ void bell(qbit q) {</span>
<span class="s">      H(q[0]);</span>
<span class="s">      CX(q[0], q[1]);</span>
<span class="s">      Measure(q[0]);</span>
<span class="s">      Measure(q[1]);</span>
<span class="s">  }</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">);</span>

  <span class="n">accelerator</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposites</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>

  <span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;local-ibm&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">5000</span><span class="p">})</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">xasm</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;xasm&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">xasm</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;__qpu__ void bell(qbit q) {</span>
<span class="s1">H(q[0]);</span>
<span class="s1">CX(q[0],q[1]);</span>
<span class="s1">Measure(q[0]);</span>
<span class="s1">Measure(q[1]);</span>
<span class="s1">}&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">)</span>

<span class="n">accelerator</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">ir</span><span class="o">.</span><span class="n">getComposites</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># note accelerators can execute lists of CompositeInstructions too</span>
<span class="c1"># usefule for executing many circuits with one remote qpu call</span>
<span class="c1"># accelerator.execute(buffer, ir.getComposites())</span>
</pre></div>
</div>
</div>
<div class="section" id="optimizer">
<h2><code class="docutils literal notranslate"><span class="pre">Optimizer</span></code><a class="headerlink" href="#optimizer" title="Permalink to this headline">¶</a></h2>
<p>This abstraction is meant for the injection of general classical multi-variate function
optimization routines. XACC provides implementations leveraging NLOpt and MLPack C++ libraries.
<code class="docutils literal notranslate"><span class="pre">Optimizer``s</span> <span class="pre">expose</span> <span class="pre">an</span> <span class="pre">``optimize()</span></code> method that takes as input an <code class="docutils literal notranslate"><span class="pre">OptFunction</span></code>, which serves as
a thin wrapper for functor-like objects exposing a specific argument structure (must take as first
arg a <code class="docutils literal notranslate"><span class="pre">vector&lt;double&gt;</span></code> representing current iterate’s parameters, and another one representing the mutable
gradient vector). Below is a demonstration of how one might use this utility:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span>
   <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">);</span>

<span class="n">optimizer</span><span class="o">-&gt;</span><span class="n">setOptions</span><span class="p">(</span>
   <span class="n">HeterogeneousMap</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-maxeval&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-optimizer&quot;</span><span class="p">,</span> <span class="s">&quot;l-bfgs&quot;</span><span class="p">)});</span>
<span class="n">OptFunction</span> <span class="nf">f</span><span class="p">(</span>
   <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">grad</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grad</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
       <span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">400</span> <span class="o">*</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
       <span class="n">grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">));</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
   <span class="p">},</span>
   <span class="mi">2</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">-&gt;</span><span class="n">optimize</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">opt_val</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">opt_params</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rosen_with_grad</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mf">400.</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">200</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">g</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;mlpack&#39;</span><span class="p">,{</span><span class="s1">&#39;mlpack-optimizer&#39;</span><span class="p">:</span><span class="s1">&#39;l-bfgs&#39;</span><span class="p">})</span>
<span class="n">opt_val</span><span class="p">,</span> <span class="n">opt_params</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">rosen_with_grad</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="xacc-qasm">
<h2><code class="docutils literal notranslate"><span class="pre">xacc::qasm</span></code><a class="headerlink" href="#xacc-qasm" title="Permalink to this headline">¶</a></h2>
<p>To improve programming efficiency, readability, and utility of the quantum kernel string
compilation, XACC exposes a <code class="docutils literal notranslate"><span class="pre">qasm()</span></code> function. This function takes as input an enhanced quantum
kernel source string syntax and compiles it to XACC IR. This source string is <em>enhanced</em> in that
it requires that extra metadata be present in order to adequately compile the quantum code.
Specifically, the source string must contain the following key words:</p>
<ul class="simple">
<li><p>a single <em>.compiler NAME</em>, to indicate which XACC compiler implementation to use.</p></li>
<li><p>one or many <em>.circuit NAME</em> calls to give the created CompositeInstruction (circuit) a name.</p></li>
<li><p>one <em>.parameters PARAM 1, PARAM 2, .., PARAM N</em> for each parameterized circuit to tell the Compiler the names of the parameters.</p></li>
<li><p>A <em>.qbit NAME</em> optional keyword can be provided when the source code itself makes reference to the <code class="docutils literal notranslate"><span class="pre">qbit</span></code> or <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code></p></li>
</ul>
<p>Running this command with the appropriately provided keywords will compile the source string to XACC IR and store it an
internal compilation database (standard map of CompositeInstruction names to CompositeInstructions), and users
can get reference to the individual CompositeInstructions via an exposed <code class="docutils literal notranslate"><span class="pre">getCompiled()</span></code> XACC API call. The
code below demonstrates how one would use <code class="docutils literal notranslate"><span class="pre">qasm()</span></code> and its overall utility.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="p">...</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s">.compiler xasm</span>
<span class="s">.circuit deuteron_ansatz</span>
<span class="s">.parameters x</span>
<span class="s">.qbit q</span>
<span class="s">for (int i = 0; i &lt; 2; i++) {</span>
<span class="s">  H(q[0]);</span>
<span class="s">}</span>
<span class="s">exp_i_theta(q, x, {{&quot;pauli&quot;, &quot;X0 Y1 - Y0 X1&quot;}});</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;deuteron_ansatz&quot;</span><span class="p">);</span>

<span class="c1">// Quil example, multiple kernels</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">.compiler quil</span>
<span class="s">.circuit ansatz</span>
<span class="s">.parameters theta, phi</span>
<span class="s">X 0</span>
<span class="s">H 2</span>
<span class="s">CNOT 2 1</span>
<span class="s">CNOT 0 1</span>
<span class="s">Rz(theta) 0</span>
<span class="s">Ry(phi) 1</span>
<span class="s">H 0</span>
<span class="s">.circuit x0x1</span>
<span class="s">ansatz(theta, phi)</span>
<span class="s">H 0</span>
<span class="s">H 1</span>
<span class="s">MEASURE 0 [0]</span>
<span class="s">MEASURE 1 [1]</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">x0x1</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;x0x1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="o">...</span>
 <span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">.compiler xasm</span>
<span class="s1">.circuit deuteron_ansatz</span>
<span class="s1">.parameters x</span>
<span class="s1">.qbit q</span>
<span class="s1">for (int i = 0; i &lt; 2; i++) {</span>
<span class="s1">  X(q[0]);</span>
<span class="s1">}</span>
<span class="s1">exp_i_theta(q, x, {{&quot;pauli&quot;, &quot;X0 Y1 - Y0 X1&quot;}});</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span>
 <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;deuteron_ansatz&#39;</span><span class="p">)</span>

<span class="c1"># Quil example, multiple kernels</span>
<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;.compiler quil</span>
<span class="s1">.circuit ansatz</span>
<span class="s1">.parameters theta, phi</span>
<span class="s1">X 0</span>
<span class="s1">H 2</span>
<span class="s1">CNOT 2 1</span>
<span class="s1">CNOT 0 1</span>
<span class="s1">Rz(theta) 0</span>
<span class="s1">Ry(phi) 1</span>
<span class="s1">H 0</span>
<span class="s1">.circuit x0x1</span>
<span class="s1">ansatz(theta, phi)</span>
<span class="s1">H 0</span>
<span class="s1">H 1</span>
<span class="s1">MEASURE 0 [0]</span>
<span class="s1">MEASURE 1 [1]</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">x0x1</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;x0x1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extensions.html" class="btn btn-neutral float-right" title="Extensions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Alex McCaskey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>