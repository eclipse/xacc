

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Extensions &mdash; XACC 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Advanced" href="advanced.html" />
    <link rel="prev" title="Basics" href="basics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> XACC
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#compilers">Compilers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#xasm">xasm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quilc">quilc</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optimizers">Optimizers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mlpack">MLPack</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nlopt">NLOpt</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#accelerators">Accelerators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ibm">IBM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aer">Aer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qcs">QCS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ionq">IonQ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dwave">DWave</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dwave-neal">DWave Neal</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quac">QuaC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qrack">Qrack</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vqe">VQE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ddcl">DDCL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rotoselect">Rotoselect</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rbm-classification">RBM Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-process-tomography">Quantum Process Tomography</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qaoa">QAOA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-phase-estimation">Quantum Phase Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qite">QITE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adapt">ADAPT</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#accelerator-decorators">Accelerator Decorators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#roerrordecorator">ROErrorDecorator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rdmpurificationdecorator">RDMPurificationDecorator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#improvedsamplingdecorator">ImprovedSamplingDecorator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vqe-restart-decorator">VQE Restart Decorator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ir-transformations">IR Transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#circuitoptimizer">CircuitOptimizer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#observables">Observables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#psi4-frozen-core">Psi4 Frozen-Core</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#circuit-generator">Circuit Generator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aswap-ansatz-circuit">ASWAP Ansatz Circuit</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developers</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XACC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Extensions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/extensions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="extensions">
<h1>Extensions<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h1>
<p>Here we detail concrete implementations of various XACC interfaces as well as any
input parameters they expose.</p>
<div class="section" id="compilers">
<h2>Compilers<a class="headerlink" href="#compilers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="xasm">
<h3>xasm<a class="headerlink" href="#xasm" title="Permalink to this headline">¶</a></h3>
<p>The XASM Compiler is the default compiler in XACC. It is the closest language to the underlying
XACC IR data model. The XASM compiler provides a quantum assembly like language with support
for custom Instructions and Composite Instruction generators as part of the language. Instructions
are provided to the language via the usual XACC service registry. Most common digital gates are provided
by default, and it is straightforward to add new Instructions.</p>
</div>
<div class="section" id="quilc">
<h3>quilc<a class="headerlink" href="#quilc" title="Permalink to this headline">¶</a></h3>
<p>XACC provides a Compiler implementation that delegates to the Rigetti-developed
quilc compiler. This is acheieved through the <code class="docutils literal notranslate"><span class="pre">rigetti/quilc</span></code> Docker image and
the internal XACC REST client API. The Quilc Compiler implementation makes direct
REST POSTs and GETs to the users local Docker Engine. Therefore,
in order to use this Compiler, you must pull down this image.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker pull rigetti/quilc
</pre></div>
</div>
<p>With that image pulled, you can now use the Quilc compiler via the usual XACC API calls.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">compiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;quilc&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">##(</span><span class="s">H 0</span>
<span class="s">CNOT 0 1</span>
<span class="dl">)##</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposites</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">compiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiler</span><span class="p">(</span><span class="s1">&#39;quilc&#39;</span><span class="p">)</span>
<span class="n">ir</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;__qpu__ void ansatz(qbit q, double x) {</span>
<span class="s1">    X 0</span>
<span class="s1">    CNOT 1 0</span>
<span class="s1">    RY(x) 1</span>
<span class="s1">}&#39;&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that you can structure your input to the compiler as a typical XACC kernel source string
or as a raw Quil string.</p>
</div>
</div>
<div class="section" id="optimizers">
<h2>Optimizers<a class="headerlink" href="#optimizers" title="Permalink to this headline">¶</a></h2>
<p>XACC provides implementations for the <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code> that delegate to NLOpt and MLPack. Here we demonstrate
the various ways to configure these optimizers for a number of different solver types.</p>
<p>In addition to the enumerated parameters below, all <code class="docutils literal notranslate"><span class="pre">Optimizers</span></code> expose an <code class="docutils literal notranslate"><span class="pre">initial-parameters</span></code> key
that must be a list or vector of doubles with size equal to the number of parameters. By default, <code class="docutils literal notranslate"><span class="pre">[0.,0.,...,0.,0.]</span></code> is used.</p>
<div class="section" id="mlpack">
<h3>MLPack<a class="headerlink" href="#mlpack" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 50%" />
<col style="width: 7%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">mlpack-optimizer</span></code></p></th>
<th class="head"><p>Optimizer Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>default</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>adam</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-beta1</p></td>
<td><p>Exponential decay rate for the first moment estimates.</p></td>
<td><p>.7</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-beta2</p></td>
<td><p>Exponential decay rate for the weighted infinity norm estimates.</p></td>
<td><p>.999</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-eps</p></td>
<td><p>Value used to initialize the mean squared gradient parameter.</p></td>
<td><p>1e-8</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td><p>l-bfgs</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>adagrad</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-eps</p></td>
<td><p>Value used to initialize the mean squared gradient parameter.</p></td>
<td><p>1e-8</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td><p>adadelta</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-eps</p></td>
<td><p>Value used to initialize the mean squared gradient parameter.</p></td>
<td><p>1e-8</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-rho</p></td>
<td><p>Smoothing constant.</p></td>
<td><p>.95</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td><p>cmaes</p></td>
<td><p>mlpack-cmaes-lambda</p></td>
<td><p>The population size.</p></td>
<td><p>0</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-cmaes-upper-bound</p></td>
<td><p>Upper bound of decision variables.</p></td>
<td><ol class="arabic simple" start="10">
<li></li>
</ol>
</td>
<td><p>duoble</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-cmaes-lower-bound</p></td>
<td><p>Lower bound of decision variables.</p></td>
<td><p>-10.0</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td><p>gd</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td><p>momentum-sgd</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-momentum</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>.05</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td><p>momentum-nesterov</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-momentum</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>.05</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td><p>sgd</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td><p>rms-prop</p></td>
<td><p>mlpack-step-size</p></td>
<td><p>Step size for each iteration.</p></td>
<td><p>.5</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-max-iter</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>500000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-tolerance</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-4</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mlpack-alpha</p></td>
<td><p>Smoothing constant</p></td>
<td><p>.99</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mlpack-eps</p></td>
<td><p>Value used to initialize the mean squared gradient parameter.</p></td>
<td><p>1e-8</p></td>
<td><p>double</p></td>
</tr>
</tbody>
</table>
<p>Various examples of using the mlpack optimizer:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// sgd with defaults</span>
<span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;mlpack&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;mlpack-optimizer&quot;</span><span class="p">,</span> <span class="s">&quot;sgd&quot;</span><span class="p">)});</span>
<span class="c1">// default adam</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;mlpack&quot;</span><span class="p">)</span>
<span class="c1">// adagrad with 30 max iters and .01 step size</span>
<span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;mlpack&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;mlpack-optimizer&quot;</span><span class="p">,</span> <span class="s">&quot;adagrad&quot;</span><span class="p">),</span>
                                               <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;mlpack-step-size&quot;</span><span class="p">,</span> <span class="mf">.01</span><span class="p">),</span>
                                               <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;mlpack-max-iter&quot;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)});</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;mlpack&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;mlpack-optimizer&#39;</span><span class="p">:</span><span class="s1">&#39;sgd&#39;</span><span class="p">})</span>
<span class="o">//</span> <span class="n">default</span> <span class="n">adam</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s2">&quot;mlpack&quot;</span><span class="p">)</span>
<span class="o">//</span> <span class="n">adagrad</span> <span class="k">with</span> <span class="mi">30</span> <span class="nb">max</span> <span class="n">iters</span> <span class="ow">and</span> <span class="o">.</span><span class="mo">01</span> <span class="n">step</span> <span class="n">size</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s2">&quot;mlpack&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;mlpack-optimizer&#39;</span><span class="p">:</span><span class="s1">&#39;adagrad&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;mlpack-step-size&#39;</span><span class="p">:</span><span class="o">.</span><span class="mo">01</span><span class="p">,</span>
                                         <span class="s1">&#39;mlpack-max-iter&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="nlopt">
<h3>NLOpt<a class="headerlink" href="#nlopt" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 50%" />
<col style="width: 7%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">nlopt-optimizer</span></code></p></th>
<th class="head"><p>Optimizer Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>default</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cobyla</p></td>
<td><p>nlopt-ftol</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-6</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>nlopt-maxeval</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>1000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>l-bfgs</p></td>
<td><p>nlopt-ftol</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-6</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>nlopt-maxeval</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>1000</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>nelder-mead</p></td>
<td><p>nlopt-ftol</p></td>
<td><p>Maximum absolute tolerance to terminate algorithm.</p></td>
<td><p>1e-6</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>nlopt-maxeval</p></td>
<td><p>Maximum number of iterations allowed</p></td>
<td><p>1000</p></td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="accelerators">
<h2>Accelerators<a class="headerlink" href="#accelerators" title="Permalink to this headline">¶</a></h2>
<p>Here we detail all available XACC <code class="docutils literal notranslate"><span class="pre">Accelerators</span></code> and their exposed input parameters.</p>
<div class="section" id="ibm">
<h3>IBM<a class="headerlink" href="#ibm" title="Permalink to this headline">¶</a></h3>
<p>The IBM Accelerator by default targets the remote <code class="docutils literal notranslate"><span class="pre">ibmq_qasm_simulator</span></code>. You can point to a
different backend in two ways:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">ibm_valencia</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm:ibmq_valencia&quot;</span><span class="p">);</span>
<span class="p">...</span> <span class="n">or</span> <span class="p">...</span>
<span class="k">auto</span> <span class="n">ibm_valencia</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;backend&quot;</span><span class="p">,</span> <span class="s">&quot;ibmq_valencia&quot;</span><span class="p">)});</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ibm_valencia</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm:ibmq_valencia&#39;</span><span class="p">);</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="n">ibm_valencia</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;backend&#39;</span><span class="p">:</span><span class="s1">&#39;ibmq_valencia&#39;</span><span class="p">)});</span>
</pre></div>
</div>
<p>You can specify the number of shots in this way as well</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">ibm_valencia</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm:ibmq_valencia&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ibm_valencia</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm:ibmq_valencia&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>In order to target the remote backend (for <code class="docutils literal notranslate"><span class="pre">initialize()</span></code> or <code class="docutils literal notranslate"><span class="pre">execute()</span></code>) you must provide
your IBM credentials to XACC. To do this add the following to a plain text file <code class="docutils literal notranslate"><span class="pre">$HOME/.ibm_config</span></code></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>key: YOUR_KEY_HERE
hub: HUB
group: GROUP
project: PROJECT
</pre></div>
</div>
<p>You can also create this file using the <code class="docutils literal notranslate"><span class="pre">xacc</span></code> Python module</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 -m xacc -c ibm -k YOUR_KEY --group GROUP --hub HUB --project PROJECT --url URL
<span class="o">[</span> <span class="k">for</span> public API <span class="o">]</span>
$ python3 -m xacc -c ibm -k YOUR_KEY
</pre></div>
</div>
<p>where you provide URL, HUB, PROJECT, GROUP, and YOUR_KEY.</p>
</div>
<div class="section" id="aer">
<h3>Aer<a class="headerlink" href="#aer" title="Permalink to this headline">¶</a></h3>
<p>The Aer Accelerator provides a great example of contributing plugins or extensions to core C++ XACC interfaces
from Python. To see how this is done, checkout the code <a class="reference external" href="https://github.com/eclipse/xacc/blob/master/python/plugins/aer/aer_accelerator.py">here</a>.
This Accelerator connects the XACC IR infrastructure with the <code class="docutils literal notranslate"><span class="pre">qiskit-aer</span></code> simulator, providing a
robust simulator that can mimic noise models published by IBM backends. Note to use these noise models you must
have setup your <code class="docutils literal notranslate"><span class="pre">$HOME/.ibm_config</span></code> file (see above discussion on IBM Accelerator).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">aer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;aer&#39;</span><span class="p">)</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="n">aer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;aer&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">8192</span><span class="p">})</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="c1"># For ibmq_johannesburg-like readout error</span>
<span class="n">aer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;aer&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">2048</span><span class="p">,</span> <span class="s1">&#39;backend&#39;</span><span class="p">:</span><span class="s1">&#39;ibmq_johannesburg&#39;</span><span class="p">,</span> <span class="s1">&#39;readout_error&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">})</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="c1"># For all ibmq_johannesburg-like errors</span>
<span class="n">aer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;aer&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">2048</span><span class="p">,</span> <span class="s1">&#39;backend&#39;</span><span class="p">:</span><span class="s1">&#39;ibmq_johannesburg&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;readout_error&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span>
                                 <span class="s1">&#39;thermal_relaxation&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span>
                                 <span class="s1">&#39;gate_error&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>You can also use this simulator from C++, just make sure you load the Python external language plugin.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">external</span><span class="o">::</span><span class="n">load_external_language_plugins</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;aer&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">8192</span><span class="p">),</span>
                                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;readout_error&quot;</span><span class="p">,</span> <span class="nb">true</span><span class="p">)});</span>
<span class="p">..</span> <span class="n">run</span> <span class="n">simulation</span>

<span class="n">xacc</span><span class="o">::</span><span class="n">external</span><span class="o">::</span><span class="n">unload_external_language_plugins</span><span class="p">();</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="qcs">
<h3>QCS<a class="headerlink" href="#qcs" title="Permalink to this headline">¶</a></h3>
<p>XACC provides support for the Rigetti QCS platform through the QCS Accelerator implementation. This
Accelerator requires a few extra third-party libraries that you will need to install in order
to get QCS support. Specifically we need <code class="docutils literal notranslate"><span class="pre">libzmq</span></code>, <code class="docutils literal notranslate"><span class="pre">cppzmq</span></code>, <code class="docutils literal notranslate"><span class="pre">msgpack-c</span></code>, and <code class="docutils literal notranslate"><span class="pre">uuid-dev</span></code>.
Note that more than likely this will only be built on the QCS Centos 7 VM, so the following
instructions are specifically for that OS.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/zeromq/libzmq
$ <span class="nb">cd</span> libzmq/ <span class="o">&amp;&amp;</span> mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
$ cmake .. -DCMAKE_INSTALL_PREFIX<span class="o">=</span>~/.zmq
$ make -j12 install

$ <span class="nb">cd</span> ../..
$ git clone https://github.com/zeromq/cppzmq
$ <span class="nb">cd</span> cppzmq/ <span class="o">&amp;&amp;</span> mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build/
$ cmake .. -DCMAKE_INSTALL_PREFIX<span class="o">=</span>~/.zmq -DCMAKE_PREFIX_PATH<span class="o">=</span>~/.zmq
$ make -j12 install

$ <span class="nb">cd</span> ../..
$ git clone https://github.com/msgpack/msgpack-c/
$ <span class="nb">cd</span> msgpack-c/ <span class="o">&amp;&amp;</span> mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
$ cmake .. -DCMAKE_INSTALL_PREFIX<span class="o">=</span>~/.zmq
$ make -j12 install
$ <span class="nb">cd</span> ../..

$ sudo yum install uuid-dev devtoolset-8-gcc devtoolset-8-gcc-c++
$ scl <span class="nb">enable</span> devtoolset-8 -- bash

<span class="o">[</span>go to your xacc build directory<span class="o">]</span>
cmake .. -DUUID_LIBRARY<span class="o">=</span>/usr/lib64/libuuid.so.1
make install
</pre></div>
</div>
<p>There is no further configuration for using the QCS platform.</p>
<p>To use the QCS Accelerator targeting something like <code class="docutils literal notranslate"><span class="pre">Aspen-4-2Q-A</span></code> (for example, replace with your lattice):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">qcs</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qcs:Aspen-4-2Q-A&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)});</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qcs</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;qcs:Aspen-4-2Q-A&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">10000</span><span class="p">)});</span>
</pre></div>
</div>
<p>For now you must manually map your <code class="docutils literal notranslate"><span class="pre">CompositeInstruction</span></code> to the correct physical bits
provided by your lattice. To do so, run</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;qcs:Aspen-4-2Q-A&#39;</span><span class="p">)</span>
<span class="p">[</span><span class="n">given</span> <span class="n">CompositeInstruction</span> <span class="n">f</span><span class="p">]</span>
<span class="n">f</span><span class="o">.</span><span class="n">defaultPlacement</span><span class="p">(</span><span class="n">qpu</span><span class="p">)</span>
<span class="p">[</span><span class="ow">or</span> <span class="n">manually</span><span class="p">]</span>
<span class="n">f</span><span class="o">.</span><span class="n">mapBits</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="ionq">
<h3>IonQ<a class="headerlink" href="#ionq" title="Permalink to this headline">¶</a></h3>
<p>The IonQ Accelerator by default targets the remote <code class="docutils literal notranslate"><span class="pre">simulator</span></code> backend. You can point to the physical
QPU in two ways:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">ionq</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ionq:qpu&quot;</span><span class="p">);</span>
<span class="p">...</span> <span class="n">or</span> <span class="p">...</span>
<span class="k">auto</span> <span class="n">ionq</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ionq&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;backend&quot;</span><span class="p">,</span> <span class="s">&quot;qpu&quot;</span><span class="p">)});</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ionq</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ionq:qpu&#39;</span><span class="p">);</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="n">ionq</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ionq&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;backend&#39;</span><span class="p">:</span><span class="s1">&#39;qpu&#39;</span><span class="p">)});</span>
</pre></div>
</div>
<p>You can specify the number of shots in this way as well</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">ionq</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ionq&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ionq</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ionq&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>In order to target the simulator or QPU (for <code class="docutils literal notranslate"><span class="pre">initialize()</span></code> or <code class="docutils literal notranslate"><span class="pre">execute()</span></code>) you must provide
your IonQ credentials to XACC. To do this add the following to a plain text file <code class="docutils literal notranslate"><span class="pre">$HOME/.ionq_config</span></code></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>key: YOUR_KEY_HERE
url: https://api.ionq.co/v0
</pre></div>
</div>
</div>
<div class="section" id="dwave">
<h3>DWave<a class="headerlink" href="#dwave" title="Permalink to this headline">¶</a></h3>
<p>The DWave Accelerator by default targets the remote <code class="docutils literal notranslate"><span class="pre">DW_2000Q_VFYC_2_1</span></code> backend. You can point to a
different backend in two ways:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;dwave:DW_2000Q&quot;</span><span class="p">);</span>
<span class="p">...</span> <span class="n">or</span> <span class="p">...</span>
<span class="k">auto</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;dwave&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;backend&quot;</span><span class="p">,</span> <span class="s">&quot;DW_2000Q&quot;</span><span class="p">)});</span>
</pre></div>
</div>
<p>in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;dwave:DW_2000Q&#39;</span><span class="p">);</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="n">dw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;dwave&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;backend&#39;</span><span class="p">:</span><span class="s1">&#39;DW_2000Q&#39;</span><span class="p">)});</span>
</pre></div>
</div>
<p>You can specify the number of shots in this way as well</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;dwave&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">dw</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;dwave&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>In order to target the remote backend (for <code class="docutils literal notranslate"><span class="pre">initialize()</span></code> or <code class="docutils literal notranslate"><span class="pre">execute()</span></code>) you must provide
your DWave credentials to XACC. To do this add the following to a plain text file <code class="docutils literal notranslate"><span class="pre">$HOME/.dwave_config</span></code></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>key: YOUR_KEY_HERE
url: https://cloud.dwavesys.com
</pre></div>
</div>
<p>You can also create this file using the <code class="docutils literal notranslate"><span class="pre">xacc</span></code> Python module</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 -m xacc -c dwave -k YOUR_KEY
</pre></div>
</div>
<p>where you provide YOUR_KEY.</p>
</div>
<div class="section" id="dwave-neal">
<h3>DWave Neal<a class="headerlink" href="#dwave-neal" title="Permalink to this headline">¶</a></h3>
<p>The DWave Neal Accelerator provides another example of contributing plugins or extensions to core C++ XACC interfaces
from Python. To see how this is done, checkout the code <a class="reference external" href="https://github.com/eclipse/xacc/blob/master/python/plugins/dwave/dwave_neal_accelerator.py">here</a>.
This Accelerator connects the XACC IR infrastructure with the <code class="docutils literal notranslate"><span class="pre">dwave-neal</span></code> simulator, providing a local
simulator that can mimic DWave QPU execution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">aer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;dwave-neal&#39;</span><span class="p">)</span>
<span class="o">...</span> <span class="ow">or</span> <span class="o">...</span>
<span class="n">aer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;dwave-neal&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">2000</span><span class="p">})</span>
</pre></div>
</div>
<p>You can also use this simulator from C++, just make sure you load the Python external language plugin.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">external</span><span class="o">::</span><span class="n">load_external_language_plugins</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;dwave-neal&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">8192</span><span class="p">)});</span>
<span class="p">..</span> <span class="n">run</span> <span class="n">simulation</span>

<span class="n">xacc</span><span class="o">::</span><span class="n">external</span><span class="o">::</span><span class="n">unload_external_language_plugins</span><span class="p">();</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="quac">
<h3>QuaC<a class="headerlink" href="#quac" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/ORNL-QCI/QuaC/tree/xacc-integration">QuaC</a> accelerator is a pulse-level accelerator (simulation only) that can execute quantum circuits at both gate and pulse (analog) level.</p>
<p>To use this accelerator, you need to build and install QuaC (see <a class="reference external" href="https://github.com/ORNL-QCI/QuaC/tree/xacc-integration#build-xacc-quac-accelerator-plugin">here</a> for instructions.)</p>
<p>In pulse mode, you need to provide the QuaC accelerator a dynamical system model
which can be constructed from an OpenPulse-format Hamiltonian JSON:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonianJson</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Hamiltonian of a one-qubit system.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
   <span class="s2">&quot;h_str&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;-0.5*omega0*Z0&quot;</span><span class="p">,</span> <span class="s2">&quot;omegaa*X0||D0&quot;</span><span class="p">],</span>
   <span class="s2">&quot;osc&quot;</span><span class="p">:</span> <span class="p">{},</span>
   <span class="s2">&quot;qub&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="mi">2</span>
   <span class="p">},</span>
   <span class="s2">&quot;vars&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;omega0&quot;</span><span class="p">:</span> <span class="mf">6.2831853</span><span class="p">,</span>
      <span class="s2">&quot;omegaa&quot;</span><span class="p">:</span> <span class="mf">0.0314159</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="c1"># Create a pulse system model object</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">createPulseModel</span><span class="p">()</span>
<span class="c1"># Load the Hamiltonian JSON (string) to the system model</span>
<span class="n">loadResult</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">loadHamiltonianJson</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">hamiltonianJson</span><span class="p">))</span>
</pre></div>
</div>
<p>The QuaC simulator can then be requested by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;QuaC&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;system-model&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">()})</span>
</pre></div>
</div>
<p>Pulse-level instructions can be constructed manually (assigning sample points)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pulseData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">pulseLength</span><span class="p">)</span>
<span class="c1"># Register the pulse named &#39;square&#39; as an XACC instruction</span>
<span class="n">xacc</span><span class="o">.</span><span class="n">addPulse</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="n">pulseData</span><span class="p">)</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getIRProvider</span><span class="p">(</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
<span class="n">squarePulseInst</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createInstruction</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">squarePulseInst</span><span class="o">.</span><span class="n">setChannel</span><span class="p">(</span><span class="s1">&#39;d0&#39;</span><span class="p">)</span>
<span class="c1"># This instruction can be added to any XACC quantum Composite Instruction</span>
<span class="n">prog</span><span class="o">.</span><span class="n">addInstruction</span><span class="p">(</span><span class="n">squarePulseInst</span><span class="p">)</span>
</pre></div>
</div>
<p>or automatically (converting from quantum gates to pulses).
To use automatic gate-to-pulse functionality, we need to load a pulse library to the accelerator as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load the backend JSON file which contains a pulse library</span>
<span class="n">backendJson</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;backends.json&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">qpu</span><span class="o">.</span><span class="n">contributeInstructions</span><span class="p">(</span><span class="n">backendJson</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information, please check out these <a class="reference external" href="https://github.com/ORNL-QCI/QuaC/tree/xacc-integration/xacc_examples/python">examples</a>.</p>
</div>
<div class="section" id="qrack">
<h3>Qrack<a class="headerlink" href="#qrack" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/vm6502q/qrack">vm6502q/qrack</a> simulator-based accelerator provides optional OpenCL-based GPU acceleration, as well as a novel simulator optimization layer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">qrk</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qrack&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)});</span>
</pre></div>
</div>
<p>By default, it selects initialization parameters that are commonly best for a wide range of use cases. However, it is highly configurable through a number of exposed parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 51%" />
<col style="width: 9%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Initialization Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
<th class="head"><p>default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>shots</p></td>
<td><p>Number of iterations to repeat the circuit for</p></td>
<td><p>int</p></td>
<td><p>-1 (Z-expectation only)</p></td>
</tr>
<tr class="row-odd"><td><p>use_opencl</p></td>
<td><p>Use OpenCL acceleration if available, (otherwise native C++11)</p></td>
<td><p>bool</p></td>
<td><p>true</p></td>
</tr>
<tr class="row-even"><td><p>use_qunit</p></td>
<td><p>Turn on the novel optimization layer, (otherwise “Schrödinger method”)</p></td>
<td><p>bool</p></td>
<td><p>true</p></td>
</tr>
<tr class="row-odd"><td><p>device_id</p></td>
<td><p>The (Qrack) device ID number of the OpenCL accelerator to use</p></td>
<td><p>int</p></td>
<td><p>-1 (auto-select)</p></td>
</tr>
<tr class="row-even"><td><p>do_normalize</p></td>
<td><p>Enable small norm probability amplitude flooring and normalization</p></td>
<td><p>bool</p></td>
<td><p>true</p></td>
</tr>
<tr class="row-odd"><td><p>zero_threshold</p></td>
<td><p>Norm threshold for clamping probability amplitudes to 0</p></td>
<td><p>double</p></td>
<td><p>1e-14/1e-30 float/double</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="algorithms">
<h2>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h2>
<p>XACC exposes hybrid quantum-classical Algorithm implementations for the variational quantum eigensolver (VQE), data-driven
circuit learning (DDCL), and chemistry reduced density matrix generation (RDM).</p>
<div class="section" id="vqe">
<h3>VQE<a class="headerlink" href="#vqe" title="Permalink to this headline">¶</a></h3>
<p>The VQE Algorithm requires the following input information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>observable</p></td>
<td><p>The hermitian operator, vqe computes ground eigenvalue of this</p></td>
<td><p>std::shared_ptr&lt;Observable&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>ansatz</p></td>
<td><p>The unmeasured, parameterized quantum circuit</p></td>
<td><p>std::shared_ptr&lt;CompositeInstruction&gt;</p></td>
</tr>
<tr class="row-even"><td><p>optimizer</p></td>
<td><p>The classical optimizer to use</p></td>
<td><p>std::shared_ptr&lt;Optimizer&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The Accelerator backend to target</p></td>
<td><p>std::shared_ptr&lt;Accelerator&gt;</p></td>
</tr>
</tbody>
</table>
<p>This Algorithm will add <code class="docutils literal notranslate"><span class="pre">opt-val</span></code> (<code class="docutils literal notranslate"><span class="pre">double</span></code>) and <code class="docutils literal notranslate"><span class="pre">opt-params</span></code> (<code class="docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;</span></code>) to the provided <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code>.
The results of the algorithm are therefore retrieved via these keys (see snippet below). Note you can
control the initial VQE parameters with the <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code> <code class="docutils literal notranslate"><span class="pre">initial-parameters</span></code> key (by default all zeros).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span> <span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
 <span class="cp">#include</span> <span class="cpf">&quot;xacc_observable.hpp&quot;</span><span class="cp"></span>

 <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

   <span class="c1">// Get reference to the Accelerator</span>
   <span class="c1">// specified by --accelerator argument</span>
   <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">();</span>

   <span class="c1">// Create the N=2 deuteron Hamiltonian</span>
   <span class="k">auto</span> <span class="n">H_N_2</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">quantum</span><span class="o">::</span><span class="n">getObservable</span><span class="p">(</span>
       <span class="s">&quot;pauli&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;5.907 - 2.1433 X0X1 &quot;</span>
                         <span class="s">&quot;- 2.1433 Y0Y1&quot;</span>
                         <span class="s">&quot;+ .21829 Z0 - 6.125 Z1&quot;</span><span class="p">));</span>

   <span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">,</span>
                          <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;initial-parameters&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mf">.5</span><span class="p">})});</span>

   <span class="c1">// JIT map Quil QASM Ansatz to IR</span>
   <span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s">  .compiler xasm</span>
<span class="s">  .circuit deuteron_ansatz</span>
<span class="s">  .parameters theta</span>
<span class="s">  .qbit q</span>
<span class="s">  X(q[0]);</span>
<span class="s">  Ry(q[1], theta);</span>
<span class="s">  CNOT(q[1],q[0]);</span>
<span class="s">  </span><span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;deuteron_ansatz&quot;</span><span class="p">);</span>

  <span class="c1">// Get the VQE Algorithm and initialize it</span>
  <span class="k">auto</span> <span class="n">vqe</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s">&quot;vqe&quot;</span><span class="p">);</span>
  <span class="n">vqe</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;ansatz&quot;</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">),</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;observable&quot;</span><span class="p">,</span> <span class="n">H_N_2</span><span class="p">),</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">),</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)});</span>

  <span class="c1">// Allocate some qubits and execute</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">vqe</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">ground_energy</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;opt-val&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;opt-params&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="c1"># Get access to the desired QPU and</span>
<span class="c1"># allocate some qubits to run on</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;tnqvm&#39;</span><span class="p">)</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Construct the Hamiltonian as an XACC-VQE PauliOperator</span>
<span class="n">ham</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;pauli&#39;</span><span class="p">,</span> <span class="s1">&#39;5.907 - 2.1433 X0X1 - 2.1433 Y0Y1 + .21829 Z0 - 6.125 Z1&#39;</span><span class="p">)</span>


<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;.compiler xasm</span>
<span class="s1">.circuit ansatz2</span>
<span class="s1">.parameters t0</span>
<span class="s1">.qbit q</span>
<span class="s1">X(q[0]);</span>
<span class="s1">Ry(q[1],t0);</span>
<span class="s1">CX(q[1],q[0]);</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">ansatz2</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;ansatz2&#39;</span><span class="p">)</span>

<span class="n">opt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;nlopt&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;initial-parameters&#39;</span><span class="p">:[</span><span class="o">.</span><span class="mi">5</span><span class="p">]})</span>

<span class="c1"># Create the VQE algorithm</span>
<span class="n">vqe</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;vqe&#39;</span><span class="p">,</span> <span class="p">{</span>
                     <span class="s1">&#39;ansatz&#39;</span><span class="p">:</span> <span class="n">ansatz2</span><span class="p">,</span>
                     <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">qpu</span><span class="p">,</span>
                     <span class="s1">&#39;observable&#39;</span><span class="p">:</span> <span class="n">ham</span><span class="p">,</span>
                     <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="n">opt</span>
                     <span class="p">})</span>
<span class="n">vqe</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
<span class="n">energy</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="s1">&#39;opt-val&#39;</span><span class="p">]</span>
<span class="n">params</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="s1">&#39;opt-params&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="ddcl">
<h3>DDCL<a class="headerlink" href="#ddcl" title="Permalink to this headline">¶</a></h3>
<p>The DDCL Algorithm implements the following algorithm - given a target probability distribution,
propose a parameterized quantum circuit and train (minimize loss) the circuit to reproduce
that given target distribution. We design DDCL to be extensible in loss function computation and
gradient computation strategies.</p>
<p>The DDCL Algorithm requires the following input information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>target_dist</p></td>
<td><p>The target probability distribution to reproduce</p></td>
<td><p>std::vector&lt;double&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>ansatz</p></td>
<td><p>The unmeasured, parameterized quantum circuit</p></td>
<td><p>std::shared_ptr&lt;CompositeInstruction&gt;</p></td>
</tr>
<tr class="row-even"><td><p>optimizer</p></td>
<td><p>The classical optimizer to use, can be gradient based</p></td>
<td><p>std::shared_ptr&lt;Optimizer&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The Accelerator backend to target</p></td>
<td><p>std::shared_ptr&lt;Accelerator&gt;</p></td>
</tr>
<tr class="row-even"><td><p>loss</p></td>
<td><p>The loss strategy to use</p></td>
<td><p>std::string</p></td>
</tr>
<tr class="row-odd"><td><p>gradient</p></td>
<td><p>The gradient strategy to use</p></td>
<td><p>std::string</p></td>
</tr>
</tbody>
</table>
<p>As of this writing, loss can take <code class="docutils literal notranslate"><span class="pre">js</span></code> and <code class="docutils literal notranslate"><span class="pre">mmd</span></code> values for Jansen-Shannon divergence and Maximum Mean Discrepancy, respectively.
More are being added. Also, gradient can take <code class="docutils literal notranslate"><span class="pre">js-parameter-shift</span></code> and <code class="docutils literal notranslate"><span class="pre">mmd-parameter-shift</span></code> values. These gradient
strategies will shift each parameter by plus or minus pi over 2.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="n">xacc</span><span class="o">::</span><span class="n">external</span><span class="o">::</span><span class="n">load_external_language_plugins</span><span class="p">();</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">set_verbose</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

  <span class="c1">// Get reference to the Accelerator</span>
  <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;aer&quot;</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;mlpack&quot;</span><span class="p">);</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s"> .compiler xasm</span>
<span class="s"> .circuit qubit2_depth1</span>
<span class="s"> .parameters x</span>
<span class="s"> .qbit q</span>
<span class="s"> U(q[0], x[0], -pi/2, pi/2 );</span>
<span class="s"> U(q[0], 0, 0, x[1]);</span>
<span class="s"> U(q[1], x[2], -pi/2, pi/2);</span>
<span class="s"> U(q[1], 0, 0, x[3]);</span>
<span class="s"> CNOT(q[0], q[1]);</span>
<span class="s"> U(q[0], 0, 0, x[4]);</span>
<span class="s"> U(q[0], x[5], -pi/2, pi/2);</span>
<span class="s"> U(q[1], 0, 0, x[6]);</span>
<span class="s"> U(q[1], x[7], -pi/2, pi/2);</span>
<span class="s"> </span><span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;qubit2_depth1&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">target_distribution</span> <span class="p">{</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">};</span>

  <span class="k">auto</span> <span class="n">ddcl</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s">&quot;ddcl&quot;</span><span class="p">);</span>
  <span class="n">ddcl</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;ansatz&quot;</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;target_dist&quot;</span><span class="p">,</span> <span class="n">target_distribution</span><span class="p">),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;loss&quot;</span><span class="p">,</span> <span class="s">&quot;js&quot;</span><span class="p">),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;gradient&quot;</span><span class="p">,</span> <span class="s">&quot;js-parameter-shift&quot;</span><span class="p">),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)});</span>

  <span class="c1">// Allocate some qubits and execute</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">ddcl</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

  <span class="c1">// Print the result</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Loss: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">[</span><span class="s">&quot;opt-val&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="n">xacc</span><span class="o">::</span><span class="n">external</span><span class="o">::</span><span class="n">unload_external_language_plugins</span><span class="p">();</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="c1"># Get the QPU and allocate a single qubit</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;aer&#39;</span><span class="p">)</span>
<span class="n">qbits</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Get the MLPack Optimizer, default is Adam</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;mlpack&#39;</span><span class="p">)</span>

<span class="c1"># Create a simple quantum program</span>
<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">.compiler xasm</span>
<span class="s1">.circuit foo</span>
<span class="s1">.parameters x,y,z</span>
<span class="s1">.qbit q</span>
<span class="s1">Ry(q[0], x);</span>
<span class="s1">Ry(q[0], y);</span>
<span class="s1">Ry(q[0], z);</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>

<span class="c1"># Get the DDCL Algorithm, initialize it</span>
<span class="c1"># with necessary parameters</span>
<span class="n">ddcl</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;ddcl&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;ansatz&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span>
                               <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">qpu</span><span class="p">,</span>
                               <span class="s1">&#39;target_dist&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">],</span>
                               <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="n">optimizer</span><span class="p">,</span>
                               <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="s1">&#39;js&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;gradient&#39;</span><span class="p">:</span> <span class="s1">&#39;js-parameter-shift&#39;</span><span class="p">})</span>
<span class="c1"># execute</span>
<span class="n">ddcl</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">qbits</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="s1">&#39;opt-val&#39;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">qbits</span><span class="p">[</span><span class="s1">&#39;opt-params&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="rotoselect">
<h3>Rotoselect<a class="headerlink" href="#rotoselect" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Rotoselect</span></code> Quantum Circuit Structure Learning Algorithm (<a class="reference external" href="https://arxiv.org/abs/1905.09692">Ostaszewski et al. (2019)</a>) requires the following input information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 52%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>observable</p></td>
<td><p>The hermitian operator, Rotoselect computes ground eigenvalue of this</p></td>
<td><p>std::shared_ptr&lt;Observable&gt;/Observable*</p></td>
</tr>
<tr class="row-odd"><td><p>layers</p></td>
<td><p>Number of circuit layers. Each layer consists of parametrized
single-qubit rotations followed by a ladder of controlled-Z gates.</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>iterations</p></td>
<td><p>The number of training iterations</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The Accelerator backend to target</p></td>
<td><p>std::shared_ptr&lt;Accelerator&gt;/Accelerator*</p></td>
</tr>
</tbody>
</table>
<p>This <code class="docutils literal notranslate"><span class="pre">Rotoselect</span></code> algorithm is designed to learn a good circuit structure
(generators of rotation are selected from the set of Pauli gates)
at fixed depth (<code class="docutils literal notranslate"><span class="pre">layers</span></code>) to minimize the cost function (<code class="docutils literal notranslate"><span class="pre">observable</span></code>).
This Algorithm will add <code class="docutils literal notranslate"><span class="pre">opt-val</span></code> (<code class="docutils literal notranslate"><span class="pre">double</span></code>) to the provided <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code>.
The result of the algorithm is therefore retrieved via this key (see snippet below).</p>
</div>
<div class="section" id="rbm-classification">
<h3>RBM Classification<a class="headerlink" href="#rbm-classification" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rbm_classification</span></code> algorithm provides an implementation that trains a
restricted boltzmann machine via sampling of a quantum annealer for the purpose of
classification. (<a class="reference external" href="https://arxiv.org/abs/1911.06259">Caldeira et al. (2019)</a>)
It exposes the following input information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 52%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nv</p></td>
<td><p>The number of visible units</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>nh</p></td>
<td><p>The number of hidden units</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>batch-size</p></td>
<td><p>The batch size, defaults to 1</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>n-gibbs-steps</p></td>
<td><p>The number of gibbs steps to use in post-processing of dwave data</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>train-steps</p></td>
<td><p>Hard-code the number of training iterations/steps, by default this is
set to -1, meaning unlimited iterations</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>epochs</p></td>
<td><p>The number of training epochs, defaults to 1</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>train-file</p></td>
<td><p>The location (relative to pwd) of the training data (as npy file)</p></td>
<td><p>string</p></td>
</tr>
<tr class="row-odd"><td><p>expectation-strategy</p></td>
<td><p>Strategy to use in computing model expectation values, can be gibbs,
quantum-annealing, discriminative, or cd</p></td>
<td><p>string</p></td>
</tr>
<tr class="row-even"><td><p>backend</p></td>
<td><p>The desired quantum-annealing backend (defaults to dwave-neal), can be
any of the available D-Wave backends, must be provided as dwave:BEND</p></td>
<td><p>string</p></td>
</tr>
<tr class="row-odd"><td><p>shots</p></td>
<td><p>The number of samples to draw from the dwave backend</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>embedding</p></td>
<td><p>The minor graph embedding to use, if not provided, one will be
computed and used for subsequent calls to the dwave backend.</p></td>
<td><p>map&lt;int, vector&lt;int&gt;&gt;</p></td>
</tr>
</tbody>
</table>
<p>Example usage in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="c1"># Create the RBM Classification algorithm</span>
<span class="n">algo</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;rbm-classification&#39;</span><span class="p">,</span>
            <span class="p">{</span>
            <span class="s1">&#39;nv&#39;</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span>
            <span class="s1">&#39;nh&#39;</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span>
            <span class="s1">&#39;train-file&#39;</span><span class="p">:</span><span class="s1">&#39;sg_train_64bits.npy&#39;</span><span class="p">,</span>
            <span class="s1">&#39;expectation-strategy&#39;</span><span class="p">:</span><span class="s1">&#39;quantum-annealing&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backend&#39;</span><span class="p">:</span><span class="s1">&#39;dwave:DW_2000Q_5&#39;</span><span class="p">,</span>
            <span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span>
            <span class="p">})</span>

<span class="n">qbits</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">()</span>
<span class="n">algo</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">qbits</span><span class="p">)</span>

<span class="c1"># get the trained RBM weights</span>
<span class="c1"># for further use and post-processing</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">qbits</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span>
<span class="n">bv</span> <span class="o">=</span> <span class="n">qbits</span><span class="p">[</span><span class="s1">&#39;bv&#39;</span><span class="p">]</span>
<span class="n">bh</span> <span class="o">=</span> <span class="n">qbits</span><span class="p">[</span><span class="s1">&#39;bh&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="quantum-process-tomography">
<h3>Quantum Process Tomography<a class="headerlink" href="#quantum-process-tomography" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">qpt</span></code> algorithm provides an implementation of Algorithm that uses linear
inversion to compute the chi process matrix for a desired circuit.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 52%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>circuit</p></td>
<td><p>The circuit to characterize</p></td>
<td><p>pointer-like CompositeInstruction</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The backend quantum computer to use</p></td>
<td><p>pointer-like Accelerator</p></td>
</tr>
<tr class="row-even"><td><p>qubit-map</p></td>
<td><p>The physical qubits to map the logical circuit onto</p></td>
<td><p>vector&lt;int&gt;</p></td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;ibm::ibmq_poughkeepsie&quot;</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">compiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;xasm&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">ir</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">__qpu__ void f(qbit q) {</span>
<span class="s">      H(q[0]);</span>
<span class="s">  }</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">qpt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s">&quot;qpt&quot;</span><span class="p">,</span> <span class="p">{</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;circuit&quot;</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
                          <span class="p">});</span>

  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">qpt</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">chi_real</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;chi-real&quot;</span><span class="p">];</span>
  <span class="k">auto</span> <span class="n">chi_imag</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;chi-imag&quot;</span><span class="p">];</span>

<span class="p">}</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>
<span class="c1"># Choose the QPU on which to</span>
<span class="c1"># characterize the process matrix for a Hadamard</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm:ibmq_poughkeepsie&#39;</span><span class="p">)</span>

<span class="c1"># Create the CompositeInstruction containing a</span>
<span class="c1"># single Hadamard instruction</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getIRProvider</span><span class="p">(</span><span class="s1">&#39;quantum&#39;</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createComposite</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
<span class="n">hadamard</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">createInstruction</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">addInstruction</span><span class="p">(</span><span class="n">hadamard</span><span class="p">)</span>

<span class="c1"># Create the Algorithm, give it the circuit</span>
<span class="c1"># to characterize and the backend to target</span>
<span class="n">qpt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;qpt&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;circuit&#39;</span><span class="p">:</span><span class="n">circuit</span><span class="p">,</span> <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span><span class="n">qpu</span><span class="p">})</span>

<span class="c1"># Allocate a qubit, this will</span>
<span class="c1"># store our tomography results</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Execute</span>
<span class="n">qpt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>

<span class="c1"># Compute the fidelity with respect to</span>
<span class="c1"># the ideal hadamard process</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">qpt</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="s1">&#39;fidelity&#39;</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;chi-theoretical-real&#39;</span><span class="p">:[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]})</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Fidelity: &#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="qaoa">
<h3>QAOA<a class="headerlink" href="#qaoa" title="Permalink to this headline">¶</a></h3>
<p>The QAOA Algorithm requires the following input information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>observable</p></td>
<td><p>The hermitian operator represents the cost Hamiltonian.</p></td>
<td><p>std::shared_ptr&lt;Observable&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>optimizer</p></td>
<td><p>The classical optimizer to use</p></td>
<td><p>std::shared_ptr&lt;Optimizer&gt;</p></td>
</tr>
<tr class="row-even"><td><p>accelerator</p></td>
<td><p>The Accelerator backend to target</p></td>
<td><p>std::shared_ptr&lt;Accelerator&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>steps</p></td>
<td><p>The number of timesteps. Corresponds to ‘p’ in the literature.
This is optional, default = 1 if not provided.</p></td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
<p>This Algorithm will add <code class="docutils literal notranslate"><span class="pre">opt-val</span></code> (<code class="docutils literal notranslate"><span class="pre">double</span></code>) and <code class="docutils literal notranslate"><span class="pre">opt-params</span></code> (<code class="docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;</span></code>) to the provided <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code>.
The results of the algorithm are therefore retrieved via these keys (see snippet below). Note you can
control the initial QAOA parameters with the <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code> <code class="docutils literal notranslate"><span class="pre">initial-parameters</span></code> key (by default all zeros).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_observable.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_service.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>

<span class="c1">// Use XACC built-in QAOA to solve a QUBO problem</span>
<span class="c1">// QUBO function:</span>
<span class="c1">// y = -5x1 - 3x2 - 8x3 - 6x4 + 4x1x2 + 8x1x3 + 2x2x3 + 10x3x4</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
   <span class="c1">// Use the Qpp simulator as the accelerator</span>
   <span class="k">auto</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qpp&quot;</span><span class="p">);</span>

   <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
   <span class="c1">// The corresponding QUBO Hamiltonian is:</span>
   <span class="k">auto</span> <span class="n">observable</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">quantum</span><span class="o">::</span><span class="n">getObservable</span><span class="p">(</span>
         <span class="s">&quot;pauli&quot;</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;-5.0 - 0.5 Z0 - 1.0 Z2 + 0.5 Z3 + 1.0 Z0 Z1 + 2.0 Z0 Z2 + 0.5 Z1 Z2 + 2.5 Z2 Z3&quot;</span><span class="p">));</span>

   <span class="k">const</span> <span class="kt">int</span> <span class="n">nbSteps</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
   <span class="k">const</span> <span class="kt">int</span> <span class="n">nbParams</span> <span class="o">=</span> <span class="n">nbSteps</span><span class="o">*</span><span class="mi">11</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">initialParams</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
   <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;&gt;</span> <span class="n">dis</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>

   <span class="c1">// Init random parameters</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbParams</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">initialParams</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">dis</span><span class="p">(</span><span class="n">gen</span><span class="p">));</span>
   <span class="p">}</span>

   <span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">,</span>
      <span class="n">xacc</span><span class="o">::</span><span class="n">HeterogeneousMap</span> <span class="p">{</span>
         <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;initial-parameters&quot;</span><span class="p">,</span> <span class="n">initialParams</span><span class="p">),</span>
         <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-maxeval&quot;</span><span class="p">,</span> <span class="n">nbParams</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="p">});</span>

   <span class="k">auto</span> <span class="n">qaoa</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getService</span><span class="o">&lt;</span><span class="n">xacc</span><span class="o">::</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;QAOA&quot;</span><span class="p">);</span>

   <span class="k">const</span> <span class="kt">bool</span> <span class="n">initOk</span> <span class="o">=</span> <span class="n">qaoa</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">),</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;observable&quot;</span><span class="p">,</span> <span class="n">observable</span><span class="p">),</span>
                           <span class="c1">// number of time steps (p) param</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;steps&quot;</span><span class="p">,</span> <span class="n">nbSteps</span><span class="p">)</span>
                        <span class="p">});</span>
   <span class="n">qaoa</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Min QUBO: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;opt-val&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span><span class="o">,</span><span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># Get access to the desired QPU and</span>
<span class="c1"># allocate some qubits to run on</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;qpp&#39;</span><span class="p">)</span>

<span class="c1"># Construct the Hamiltonian as an XACC PauliOperator</span>
<span class="c1"># This Hamiltonian corresponds to the QUBO problem:</span>
<span class="c1"># y = -5x_1 -3x_2 -8x_3 -6x_4 + 4x_1x_2 + 8x_1x_3 + 2x_2x_3 + 10x_3x_4</span>
<span class="n">ham</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;pauli&#39;</span><span class="p">,</span> <span class="s1">&#39;-5.0 - 0.5 Z0 - 1.0 Z2 + 0.5 Z3 + 1.0 Z0 Z1 + 2.0 Z0 Z2 + 0.5 Z1 Z2 + 2.5 Z2 Z3&#39;</span><span class="p">)</span>

<span class="c1"># We need 4 qubits</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># There are 7 gamma terms (non-identity) in the cost Hamiltonian</span>
<span class="c1"># and 4 beta terms for mixer Hamiltonian</span>
<span class="n">nbParamsPerStep</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">4</span>

<span class="c1"># The number of steps (often referred to as &#39;p&#39; parameter):</span>
<span class="c1"># alternating layers of mixer and cost Hamiltonian exponential.</span>
<span class="n">nbSteps</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1"># Total number of params</span>
<span class="n">nbTotalParams</span> <span class="o">=</span> <span class="n">nbParamsPerStep</span> <span class="o">*</span> <span class="n">nbSteps</span>

<span class="c1"># Init params randomly:</span>
<span class="n">initParams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">nbTotalParams</span><span class="p">)</span>

<span class="c1"># The optimizer: nlopt</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;nlopt&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="s1">&#39;initial-parameters&#39;</span><span class="p">:</span> <span class="n">initParams</span> <span class="p">})</span>

<span class="c1"># Create the QAOA algorithm</span>
<span class="n">qaoa</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;QAOA&#39;</span><span class="p">,</span> <span class="p">{</span>
                        <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">qpu</span><span class="p">,</span>
                        <span class="s1">&#39;observable&#39;</span><span class="p">:</span> <span class="n">ham</span><span class="p">,</span>
                        <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="n">opt</span><span class="p">,</span>
                        <span class="s1">&#39;steps&#39;</span><span class="p">:</span> <span class="n">nbSteps</span>
                        <span class="p">})</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">qaoa</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Min QUBO value = &#39;</span><span class="p">,</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getInformation</span><span class="p">(</span><span class="s1">&#39;opt-val&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="quantum-phase-estimation">
<h3>Quantum Phase Estimation<a class="headerlink" href="#quantum-phase-estimation" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">QPE</span></code> algorithm (also known as quantum eigenvalue estimation algorithm) provides
an implementation of Algorithm that estimates the phase (or eigenvalue) of an eigenvector of a unitary operator.</p>
<p>Here the unitary operator is called an <cite>oracle</cite> which is a quantum subroutine
that acts upon a set of qubits and returns the answer as a phase.
The bits precision is automatically inferred from the size of the input buffer.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 52%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>oracle</p></td>
<td><p>The circuit represents the unitary operator.</p></td>
<td><p>pointer-like CompositeInstruction</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The backend quantum computer to use.</p></td>
<td><p>pointer-like Accelerator</p></td>
</tr>
<tr class="row-even"><td><p>state-preparation</p></td>
<td><p>The circuit to prepare the eigen state.</p></td>
<td><p>pointer-like CompositeInstruction</p></td>
</tr>
</tbody>
</table>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_service.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
<span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="c1">// Accelerator:</span>
<span class="k">auto</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qpp&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;shots&quot;</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)});</span>

<span class="c1">// In this example: we want to estimate the *phase* of an arbitrary &#39;oracle&#39;</span>
<span class="c1">// i.e. Oracle(|State&gt;) = exp(i*Phase)*|State&gt;</span>
<span class="c1">// and we need to estimate that Phase.</span>

<span class="c1">// Oracle: CPhase(theta) or CU1(theta) which is defined as</span>
<span class="c1">// 1 0 0 0</span>
<span class="c1">// 0 1 0 0</span>
<span class="c1">// 0 0 1 0</span>
<span class="c1">// 0 0 0 e^(i*theta)</span>
<span class="c1">// The eigenstate is |11&gt;; i.e. CPhase(theta)|11&gt; = e^(i*theta)|11&gt;</span>

<span class="c1">// Since this oracle operates on 2 qubits, we need to add more qubits to the buffer.</span>
<span class="c1">// The more qubits we have, the more accurate the estimate.</span>
<span class="c1">// Resolution := 2^(number qubits in the calculation register).</span>
<span class="c1">// 5-bit precision =&gt; 7 qubits in total</span>
<span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">qpe</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getService</span><span class="o">&lt;</span><span class="n">xacc</span><span class="o">::</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;QPE&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">compiler</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiler</span><span class="p">(</span><span class="s">&quot;xasm&quot;</span><span class="p">);</span>

<span class="c1">// Create oracle: CPhase gate with theta = 2pi/3</span>
<span class="c1">// i.e. the phase value to estimate is 1/3 ~ 0.33333.</span>
<span class="k">auto</span> <span class="n">gateRegistry</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getService</span><span class="o">&lt;</span><span class="n">xacc</span><span class="o">::</span><span class="n">IRProvider</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;quantum&quot;</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">oracle</span> <span class="o">=</span> <span class="n">gateRegistry</span><span class="o">-&gt;</span><span class="n">createComposite</span><span class="p">(</span><span class="s">&quot;oracle&quot;</span><span class="p">);</span>
<span class="n">oracle</span><span class="o">-&gt;</span><span class="n">addInstruction</span><span class="p">(</span><span class="n">gateRegistry</span><span class="o">-&gt;</span><span class="n">createInstruction</span><span class="p">(</span><span class="s">&quot;CPhase&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_PI</span><span class="o">/</span> <span class="mf">3.0</span> <span class="p">}));</span>

<span class="c1">// Eigenstate preparation = |11&gt; state</span>
<span class="k">auto</span> <span class="n">statePrep</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">-&gt;</span><span class="n">compile</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">__qpu__ void prep1(qbit q) {</span>
<span class="s">   X(q[0]);</span>
<span class="s">   X(q[1]);</span>
<span class="s">}</span><span class="dl">)</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getComposite</span><span class="p">(</span><span class="s">&quot;prep1&quot;</span><span class="p">);</span>

<span class="c1">// Initialize the Quantum Phase Estimation:</span>
<span class="n">qpe</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;oracle&quot;</span><span class="p">,</span> <span class="n">oracle</span><span class="p">),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;state-preparation&quot;</span><span class="p">,</span> <span class="n">statePrep</span><span class="p">)</span>
                  <span class="p">});</span>

<span class="c1">// Run the algorithm</span>
<span class="n">qpe</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="c1">// Expected result:</span>
<span class="c1">// The factor here is 2^5 (precision) = 32</span>
<span class="c1">// we expect the two most-likely bitstring is 10 and 11</span>
<span class="c1">// i.e. the true result is between 10/32 = 0.3125 and 11/32 = 0.34375</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Probability of the two most-likely bitstrings 10 (theta = 0.3125) and 11 (theta = 0.34375 ): </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Probability of |11010&gt; (11) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">computeMeasurementProbability</span><span class="p">(</span><span class="s">&quot;11010&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Probability of |01010&gt; (10) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">computeMeasurementProbability</span><span class="p">(</span><span class="s">&quot;01010&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or in Python</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span><span class="o">,</span><span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># Get access to the desired QPU and</span>
<span class="c1"># allocate some qubits to run on</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;qpp&#39;</span><span class="p">,</span>  <span class="p">{</span> <span class="s1">&#39;shots&#39;</span><span class="p">:</span> <span class="mi">4096</span> <span class="p">})</span>

<span class="c1"># In this example: we want to estimate the *phase* of an arbitrary &#39;oracle&#39;</span>
<span class="c1"># i.e. Oracle(|State&gt;) = exp(i*Phase)*|State&gt;</span>
<span class="c1"># and we need to estimate that Phase.</span>

<span class="c1"># The oracle is a simple T gate, and the eigenstate is |1&gt;</span>
<span class="c1"># T|1&gt; = e^(i*pi/4)|1&gt;</span>
<span class="c1"># The phase value of pi/4 = 2pi * (1/8)</span>
<span class="c1"># i.e. if we use a 3-bit register for estimation,</span>
<span class="c1"># we will get the correct answer of 1 deterministically.</span>

<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;.compiler xasm</span>
<span class="s1">.circuit oracle</span>
<span class="s1">.qbit q</span>
<span class="s1">T(q[0]);</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">oracle</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;oracle&#39;</span><span class="p">)</span>

<span class="c1"># We need to prepare the eigenstate |1&gt;</span>
<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;.compiler xasm</span>
<span class="s1">.circuit prep</span>
<span class="s1">.qbit q</span>
<span class="s1">X(q[0]);</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">statePrep</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;prep&#39;</span><span class="p">)</span>

<span class="c1"># We need 4 qubits (3-bit precision)</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Create the QPE algorithm</span>
<span class="n">qpe</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;QPE&#39;</span><span class="p">,</span> <span class="p">{</span>
                        <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">qpu</span><span class="p">,</span>
                        <span class="s1">&#39;oracle&#39;</span><span class="p">:</span> <span class="n">oracle</span><span class="p">,</span>
                        <span class="s1">&#39;state-preparation&#39;</span><span class="p">:</span> <span class="n">statePrep</span>
                        <span class="p">})</span>

<span class="n">qpe</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
<span class="c1"># We should only get the bit string of |100&gt; = 1</span>
<span class="c1"># i.e. phase value of 1/2^3 = 1/8.</span>
<span class="k">print</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="qite">
<h3>QITE<a class="headerlink" href="#qite" title="Permalink to this headline">¶</a></h3>
<p>The Quantum Imaginary Time Evolution (QITE) Algorithm requires the following input information:
(<a class="reference external" href="https://arxiv.org/pdf/1901.07653.pdf">Motta et al. (2020)</a>)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>observable</p></td>
<td><p>The hermitian operator represents the cost Hamiltonian.</p></td>
<td><p>std::shared_ptr&lt;Observable&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The Accelerator backend to target</p></td>
<td><p>std::shared_ptr&lt;Accelerator&gt;</p></td>
</tr>
<tr class="row-even"><td><p>steps</p></td>
<td><p>The number of Trotter steps.</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>step-size</p></td>
<td><p>The Trotter step size.</p></td>
<td><p>double</p></td>
</tr>
</tbody>
</table>
<p>Optionally, users can provide these parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ansatz</p></td>
<td><p>State preparation circuit.</p></td>
<td><p>std::shared_ptr&lt;CompositeInstruction&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>analytical</p></td>
<td><p>If true, perform an analytical run rather than
executing quantum circuits on the Accelerator backend.</p></td>
<td><p>boolean</p></td>
</tr>
<tr class="row-even"><td><p>initial-state</p></td>
<td><p>For <cite>analytical</cite> mode only, select the initial state.</p></td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
<p>This Algorithm will add <code class="docutils literal notranslate"><span class="pre">opt-val</span></code> (<code class="docutils literal notranslate"><span class="pre">double</span></code>) which is the energy value at the final Trotter step to the provided <code class="docutils literal notranslate"><span class="pre">AcceleratorBuffer</span></code>.
The results of the algorithm are therefore retrieved via these keys (see snippet below).
Also, energy values at each Trotter step are stored in the <code class="docutils literal notranslate"><span class="pre">exp-vals</span></code> field (<code class="docutils literal notranslate"><span class="pre">vector&lt;double&gt;</span></code>).</p>
<p>Note: during execution, the following line may be logged to the output console:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">warning</span><span class="p">:</span> <span class="n">solve</span><span class="p">()</span><span class="o">:</span> <span class="n">system</span> <span class="n">seems</span> <span class="n">singular</span><span class="p">;</span> <span class="n">attempting</span> <span class="n">approx</span> <span class="n">solution</span>
</pre></div>
</div>
<p>This is completely normal and can be safely ignored.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_observable.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_service.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
   <span class="c1">// Use the Qpp simulator as the accelerator</span>
   <span class="k">auto</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qpp&quot;</span><span class="p">);</span>

   <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
   <span class="k">auto</span> <span class="n">observable</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">quantum</span><span class="o">::</span><span class="n">getObservable</span><span class="p">(</span>
         <span class="s">&quot;pauli&quot;</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;0.7071067811865475 X0 + 0.7071067811865475 Z0&quot;</span><span class="p">));</span>

   <span class="k">auto</span> <span class="n">qite</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getService</span><span class="o">&lt;</span><span class="n">xacc</span><span class="o">::</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;qite&quot;</span><span class="p">);</span>
   <span class="k">const</span> <span class="kt">int</span> <span class="n">nbSteps</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
   <span class="k">const</span> <span class="kt">double</span> <span class="n">stepSize</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>

   <span class="k">const</span> <span class="kt">bool</span> <span class="n">initOk</span> <span class="o">=</span>  <span class="n">qite</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;steps&quot;</span><span class="p">,</span> <span class="n">nbSteps</span><span class="p">),</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;observable&quot;</span><span class="p">,</span> <span class="n">observable</span><span class="p">),</span>
      <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;step-size&quot;</span><span class="p">,</span> <span class="n">stepSize</span><span class="p">)</span>
   <span class="p">});</span>

   <span class="n">qite</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Min Energy: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;opt-val&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span><span class="o">,</span><span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="c1"># Get access to the desired QPU and</span>
<span class="c1"># allocate some qubits to run on</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;qpp&#39;</span><span class="p">)</span>

<span class="c1"># Construct the Hamiltonian as an XACC PauliOperator</span>
<span class="n">ham</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;pauli&#39;</span><span class="p">,</span> <span class="s1">&#39;0.70710678118 X0 + 0.70710678118 Z0&#39;</span><span class="p">)</span>

<span class="c1"># We just need 1 qubit</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Horizontal axis: 0 -&gt; 2.5</span>
<span class="c1"># The number of Trotter steps</span>
<span class="n">nbSteps</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1"># The Trotter step size</span>
<span class="n">stepSize</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># Create the QITE algorithm</span>
<span class="n">qite</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;qite&#39;</span><span class="p">,</span> <span class="p">{</span>
                        <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">qpu</span><span class="p">,</span>
                        <span class="s1">&#39;observable&#39;</span><span class="p">:</span> <span class="n">ham</span><span class="p">,</span>
                        <span class="s1">&#39;step-size&#39;</span><span class="p">:</span> <span class="n">stepSize</span><span class="p">,</span>
                        <span class="s1">&#39;steps&#39;</span><span class="p">:</span> <span class="n">nbSteps</span>
                        <span class="p">})</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">qite</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>

<span class="c1"># Expected result: ~ -1</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Min energy value = &#39;</span><span class="p">,</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getInformation</span><span class="p">(</span><span class="s1">&#39;opt-val&#39;</span><span class="p">))</span>
<span class="n">E</span> <span class="o">=</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">getInformation</span><span class="p">(</span><span class="s1">&#39;exp-vals&#39;</span><span class="p">)</span>
<span class="c1"># Plot energy vs. beta</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbSteps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stepSize</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;XACC QITE&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="adapt">
<h3>ADAPT<a class="headerlink" href="#adapt" title="Permalink to this headline">¶</a></h3>
<p>The Adaptive Derivative Assembled Problem Tailored (ADAPT) Algorithm requires the following input information:
(<a class="reference external" href="https://arxiv.org/pdf/1812.11173.pdf">Grismley et al. (2018)</a>, <a class="reference external" href="https://arxiv.org/pdf/1911.10205.pdf">Tang et al. (2019)</a>, <a class="reference external" href="https://arxiv.org/pdf/2005.10258.pdf">Zhu et al. (2020)</a>)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>observable</p></td>
<td><p>The hermitian operator represents the Hamiltonian</p></td>
<td><p>std::shared_ptr&lt;Observable&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>accelerator</p></td>
<td><p>The Accelerator backend to target</p></td>
<td><p>std::shared_ptr&lt;Accelerator&gt;</p></td>
</tr>
<tr class="row-even"><td><p>optimizer</p></td>
<td><p>The classical optimizer to use</p></td>
<td><p>std::shared_ptr&lt;Optimizer&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>pool</p></td>
<td><p>Pool of operators to construct adaptive ansatz</p></td>
<td><p>std::string</p></td>
</tr>
<tr class="row-even"><td><p>sub-algorithm</p></td>
<td><p>Algorithm called by ADAPT (VQE or QAOA)</p></td>
<td><p>std::string</p></td>
</tr>
</tbody>
</table>
<p>Optionally, users can provide these parameters:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>initial-state</p></td>
<td><p>State preparation circuit.</p></td>
<td><p>std::shared_ptr&lt;CompositeInstruction&gt;</p></td>
</tr>
<tr class="row-odd"><td><p>n-electrons</p></td>
<td><p>Required parameter for VQE, unless initial-state is provided</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>maxiter</p></td>
<td><p>Maximum number of ADAPT cycles/number of layers in QAOA</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>print-threshold</p></td>
<td><p>Value above which commutators are printed (Default 1.0e-10)</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-even"><td><p>adapt-threshold</p></td>
<td><p>Stops ADAPT when norm of gradient vector falls below this value
(Default 1.0e-2)</p></td>
<td><p>double</p></td>
</tr>
</tbody>
</table>
<p>ADAPT-VQE</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_observable.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_service.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="c1">// Get reference to the Accelerator</span>
  <span class="c1">// specified by --accelerator argument</span>
  <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qpp&quot;</span><span class="p">);</span>

  <span class="c1">// Get reference to the Optimizer</span>
  <span class="c1">// specified by --optimizer argument</span>
  <span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-optimizer&quot;</span><span class="p">,</span> <span class="s">&quot;l-bfgs&quot;</span><span class="p">)});</span>

  <span class="c1">// Allocate 4 qubits in the buffer</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

  <span class="c1">// Instantiate ADAPT algorithm</span>
  <span class="k">auto</span> <span class="n">adapt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getService</span><span class="o">&lt;</span><span class="n">xacc</span><span class="o">::</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;adapt&quot;</span><span class="p">);</span>

  <span class="c1">// Number of electrons</span>
  <span class="kt">int</span> <span class="n">nElectrons</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Specify the operator pool</span>
  <span class="k">auto</span> <span class="n">pool</span> <span class="o">=</span> <span class="s">&quot;qubit-pool&quot;</span><span class="p">;</span>

  <span class="c1">// Specify the sub algorithm</span>
  <span class="k">auto</span> <span class="n">subAlgo_vqe</span> <span class="o">=</span> <span class="s">&quot;vqe&quot;</span><span class="p">;</span>

  <span class="c1">// This is the H2 Hamiltonian in a fermionic basis</span>
  <span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;(-0.165606823582,-0)  1^ 2^ 1 2 + (0.120200490713,0)  1^ 0^ 0 1 + &quot;</span>
                          <span class="s">&quot;(-0.0454063328691,-0)  0^ 3^ 1 2 + (0.168335986252,0)  2^ 0^ 0 2 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  1^ 2^ 3 0 + (0.168335986252,0)  0^ 2^ 2 0 + &quot;</span>
                          <span class="s">&quot;(0.165606823582,0)  0^ 3^ 3 0 + (-0.0454063328691,-0)  3^ 0^ 2 1 + &quot;</span>
                          <span class="s">&quot;(-0.0454063328691,-0)  1^ 3^ 0 2 + (-0.0454063328691,-0)  3^ 1^ 2 0 + &quot;</span>
                          <span class="s">&quot;(0.165606823582,0)  1^ 2^ 2 1 + (-0.165606823582,-0)  0^ 3^ 0 3 + &quot;</span>
                          <span class="s">&quot;(-0.479677813134,-0)  3^ 3 + (-0.0454063328691,-0)  1^ 2^ 0 3 + &quot;</span>
                          <span class="s">&quot;(-0.174072892497,-0)  1^ 3^ 1 3 + (-0.0454063328691,-0)  0^ 2^ 1 3 + &quot;</span>
                          <span class="s">&quot;(0.120200490713,0)  0^ 1^ 1 0 + (0.0454063328691,0)  0^ 2^ 3 1 + &quot;</span>
                          <span class="s">&quot;(0.174072892497,0)  1^ 3^ 3 1 + (0.165606823582,0)  2^ 1^ 1 2 + &quot;</span>
                          <span class="s">&quot;(-0.0454063328691,-0)  2^ 1^ 3 0 + (-0.120200490713,-0)  2^ 3^ 2 3 + &quot;</span>
                          <span class="s">&quot;(0.120200490713,0)  2^ 3^ 3 2 + (-0.168335986252,-0)  0^ 2^ 0 2 + &quot;</span>
                          <span class="s">&quot;(0.120200490713,0)  3^ 2^ 2 3 + (-0.120200490713,-0)  3^ 2^ 3 2 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  1^ 3^ 2 0 + (-1.2488468038,-0)  0^ 0 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  3^ 1^ 0 2 + (-0.168335986252,-0)  2^ 0^ 2 0 + &quot;</span>
                          <span class="s">&quot;(0.165606823582,0)  3^ 0^ 0 3 + (-0.0454063328691,-0)  2^ 0^ 3 1 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  2^ 0^ 1 3 + (-1.2488468038,-0)  2^ 2 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  2^ 1^ 0 3 + (0.174072892497,0)  3^ 1^ 1 3 + &quot;</span>
                          <span class="s">&quot;(-0.479677813134,-0)  1^ 1 + (-0.174072892497,-0)  3^ 1^ 3 1 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  3^ 0^ 1 2 + (-0.165606823582,-0)  3^ 0^ 3 0 + &quot;</span>
                          <span class="s">&quot;(0.0454063328691,0)  0^ 3^ 2 1 + (-0.165606823582,-0)  2^ 1^ 2 1 + &quot;</span>
                          <span class="s">&quot;(-0.120200490713,-0)  0^ 1^ 0 1 + (-0.120200490713,-0)  1^ 0^ 1 0 + (0.7080240981,0)&quot;</span><span class="p">);</span>


  <span class="c1">// Create Observable from Hamiltonian string</span>
  <span class="k">auto</span> <span class="n">H</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">quantum</span><span class="o">::</span><span class="n">getObservable</span><span class="p">(</span><span class="s">&quot;fermion&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

  <span class="c1">// Pass parameters to ADAPT algorithm</span>
  <span class="n">adapt</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;observable&quot;</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;pool&quot;</span><span class="p">,</span> <span class="n">pool</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;n-electrons&quot;</span><span class="p">,</span> <span class="n">nElectrons</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;sub-algorithm&quot;</span><span class="p">,</span> <span class="n">subAlgo_vqe</span><span class="p">)</span>
                                <span class="p">});</span>

  <span class="c1">// Execute ADAPT-VQE</span>
  <span class="n">adapt</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

  <span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;qpp&#39;</span><span class="p">)</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;nlopt&#39;</span><span class="p">,{</span><span class="s1">&#39;nlopt-optimizer&#39;</span><span class="p">:</span><span class="s1">&#39;l-bfgs&#39;</span><span class="p">})</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="n">opstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">(-0.165606823582,-0)  1^ 2^ 1 2 + (0.120200490713,0)  1^ 0^ 0 1 +</span>
<span class="s1">(-0.0454063328691,-0)  0^ 3^ 1 2 + (0.168335986252,0)  2^ 0^ 0 2 +</span>
<span class="s1">(0.0454063328691,0)  1^ 2^ 3 0 + (0.168335986252,0)  0^ 2^ 2 0 +</span>
<span class="s1">(0.165606823582,0)  0^ 3^ 3 0 + (-0.0454063328691,-0)  3^ 0^ 2 1 +</span>
<span class="s1">(-0.0454063328691,-0)  1^ 3^ 0 2 + (-0.0454063328691,-0)  3^ 1^ 2 0 +</span>
<span class="s1">(0.165606823582,0)  1^ 2^ 2 1 + (-0.165606823582,-0)  0^ 3^ 0 3 +</span>
<span class="s1">(-0.479677813134,-0)  3^ 3 + (-0.0454063328691,-0)  1^ 2^ 0 3 +</span>
<span class="s1">(-0.174072892497,-0)  1^ 3^ 1 3 + (-0.0454063328691,-0)  0^ 2^ 1 3 +</span>
<span class="s1">(0.120200490713,0)  0^ 1^ 1 0 + (0.0454063328691,0)  0^ 2^ 3 1 +</span>
<span class="s1">(0.174072892497,0)  1^ 3^ 3 1 + (0.165606823582,0)  2^ 1^ 1 2 +</span>
<span class="s1">(-0.0454063328691,-0)  2^ 1^ 3 0 + (-0.120200490713,-0)  2^ 3^ 2 3 +</span>
<span class="s1">(0.120200490713,0)  2^ 3^ 3 2 + (-0.168335986252,-0)  0^ 2^ 0 2 +</span>
<span class="s1">(0.120200490713,0)  3^ 2^ 2 3 + (-0.120200490713,-0)  3^ 2^ 3 2 +</span>
<span class="s1">(0.0454063328691,0)  1^ 3^ 2 0 + (-1.2488468038,-0)  0^ 0 +</span>
<span class="s1">(0.0454063328691,0)  3^ 1^ 0 2 + (-0.168335986252,-0)  2^ 0^ 2 0 +</span>
<span class="s1">(0.165606823582,0)  3^ 0^ 0 3 + (-0.0454063328691,-0)  2^ 0^ 3 1 +</span>
<span class="s1">(0.0454063328691,0)  2^ 0^ 1 3 + (-1.2488468038,-0)  2^ 2 +</span>
<span class="s1">(0.0454063328691,0)  2^ 1^ 0 3 + (0.174072892497,0)  3^ 1^ 1 3 +</span>
<span class="s1">(-0.479677813134,-0)  1^ 1 + (-0.174072892497,-0)  3^ 1^ 3 1 +</span>
<span class="s1">(0.0454063328691,0)  3^ 0^ 1 2 + (-0.165606823582,-0)  3^ 0^ 3 0 +</span>
<span class="s1">(0.0454063328691,0)  0^ 3^ 2 1 + (-0.165606823582,-0)  2^ 1^ 2 1 +</span>
<span class="s1">(-0.120200490713,-0)  0^ 1^ 0 1 + (-0.120200490713,-0)  1^ 0^ 1 0 + (0.7080240981,0)</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;fermion&#39;</span><span class="p">,</span> <span class="n">opstr</span><span class="p">)</span>

<span class="n">adapt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;adapt&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">qpu</span><span class="p">,</span>
                                  <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="n">optimizer</span><span class="p">,</span>
                                  <span class="s1">&#39;observable&#39;</span><span class="p">:</span> <span class="n">H</span><span class="p">,</span>
                                  <span class="s1">&#39;n-electrons&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                                  <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                                  <span class="s1">&#39;sub-algorithm&#39;</span><span class="p">:</span> <span class="s1">&#39;vqe&#39;</span><span class="p">,</span>
                                  <span class="s1">&#39;pool&#39;</span><span class="p">:</span> <span class="s1">&#39;qubit-pool&#39;</span><span class="p">})</span>

<span class="n">adapt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
</pre></div>
</div>
<p>ADAPT-QAOA</p>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_observable.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_service.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="c1">// Get reference to the Accelerator</span>
  <span class="c1">// specified by --accelerator argument</span>
  <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qpp&quot;</span><span class="p">);</span>

  <span class="c1">// Get reference to the Optimizer</span>
  <span class="c1">// specified by --optimizer argument</span>
  <span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;nlopt-optimizer&quot;</span><span class="p">,</span> <span class="s">&quot;l-bfgs&quot;</span><span class="p">)});</span>

  <span class="c1">// Allocate 4 qubits in the buffer</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

  <span class="c1">// Instantiate ADAPT algorithm</span>
  <span class="k">auto</span> <span class="n">adapt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getService</span><span class="o">&lt;</span><span class="n">xacc</span><span class="o">::</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;adapt&quot;</span><span class="p">);</span>

  <span class="c1">// Specify the operator pool</span>
  <span class="k">auto</span> <span class="n">pool</span> <span class="o">=</span> <span class="s">&quot;multi-qubit-qaoa&quot;</span><span class="p">;</span>

  <span class="c1">// Specify the sub algorithm</span>
  <span class="k">auto</span> <span class="n">subAlgo_qaoa</span> <span class="o">=</span> <span class="s">&quot;QAOA&quot;</span><span class="p">;</span>

  <span class="c1">// Number of layers</span>
  <span class="k">auto</span> <span class="n">nLayers</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// This is the cost Hamiltonian</span>
  <span class="k">auto</span> <span class="n">H</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">quantum</span><span class="o">::</span><span class="n">getObservable</span><span class="p">(</span>
      <span class="s">&quot;pauli&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;-5.0 - 0.5 Z0 - 1.0 Z2 + 0.5 Z3 + 1.0 Z0 Z1 + 2.0 Z0 Z2 + 0.5 Z1 Z2 + 2.5 Z2 Z3&quot;</span><span class="p">));</span>

  <span class="c1">// Pass parameters to ADAPT algorithm</span>
  <span class="n">adapt</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;observable&quot;</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;pool&quot;</span><span class="p">,</span> <span class="n">pool</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;maxiter&quot;</span><span class="p">,</span> <span class="n">nLayers</span><span class="p">),</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;sub-algorithm&quot;</span><span class="p">,</span> <span class="n">subAlgo_qaoa</span><span class="p">)</span>
                                <span class="p">});</span>

  <span class="c1">// Execute ADAPT-QAOA</span>
  <span class="n">adapt</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

  <span class="n">xacc</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s2">&quot;qpp&quot;</span><span class="p">)</span>

<span class="nb">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s1">&#39;nlopt&#39;</span><span class="p">,{</span><span class="s1">&#39;nlopt-optimizer&#39;</span><span class="p">:</span><span class="s1">&#39;l-bfgs&#39;</span><span class="p">})</span>

<span class="n">pool</span> <span class="o">=</span> <span class="s2">&quot;multi-qubit-qaoa&quot;</span>

<span class="n">nLayers</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">subAlgo_qaoa</span> <span class="o">=</span> <span class="s2">&quot;QAOA&quot;</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;pauli&#39;</span><span class="p">,</span> <span class="s1">&#39;-5.0 - 0.5 Z0 - 1.0 Z2 + 0.5 Z3 + 1.0 Z0 Z1 + 2.0 Z0 Z2 + 0.5 Z1 Z2 + 2.5 Z2 Z3&#39;</span><span class="p">)</span>

<span class="n">adapt</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s1">&#39;adapt&#39;</span><span class="p">,</span> <span class="p">{</span>
                        <span class="s1">&#39;accelerator&#39;</span><span class="p">:</span> <span class="n">accelerator</span><span class="p">,</span>
                        <span class="s1">&#39;observable&#39;</span><span class="p">:</span> <span class="n">H</span><span class="p">,</span>
                        <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="n">optimizer</span><span class="p">,</span>
                        <span class="s1">&#39;pool&#39;</span><span class="p">:</span> <span class="n">pool</span><span class="p">,</span>
                        <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">nLayers</span><span class="p">,</span>
                        <span class="s1">&#39;sub-algorithm&#39;</span><span class="p">:</span> <span class="n">subAlgo_qaoa</span>
                        <span class="p">})</span>

<span class="n">adapt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="accelerator-decorators">
<h2>Accelerator Decorators<a class="headerlink" href="#accelerator-decorators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="roerrordecorator">
<h3>ROErrorDecorator<a class="headerlink" href="#roerrordecorator" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ROErrorDecorator</span></code> provides an <code class="docutils literal notranslate"><span class="pre">AcceleratorDecorator</span></code> implementation for affecting
readout error mitigation as in the <a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.120.210501">deuteron paper</a>.
It takes as input readout error probabilities <code class="docutils literal notranslate"><span class="pre">p(0|1)</span></code> and <code class="docutils literal notranslate"><span class="pre">p(1|0)</span></code> for all qubits and shifts expecation values
accordingly (see paper).</p>
<p>By default it will request the backend properties from the decorated <code class="docutils literal notranslate"><span class="pre">Accelerator</span></code> (<code class="docutils literal notranslate"><span class="pre">Accelerator::getProperties()</span></code>). This method
returns a <code class="docutils literal notranslate"><span class="pre">HeterogeneousMap</span></code>. If this map contains a vector of doubles at keys <code class="docutils literal notranslate"><span class="pre">p01s</span></code> and <code class="docutils literal notranslate"><span class="pre">p10s</span></code>, then these
values will be used in the readout error correction. Alternatively, if the backend does not provide this data,
users can provide a custom JSON file containing the probabilities. This file should be structured as such</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span>
    <span class="s2">&quot;shots&quot;</span>: <span class="m">1024</span>,
    <span class="s2">&quot;backend&quot;</span>: <span class="s2">&quot;qcs:Aspen-2Q-A&quot;</span>,
    <span class="s2">&quot;0&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;0|1&quot;</span>: <span class="m">0</span>.0565185546875,
        <span class="s2">&quot;1|0&quot;</span>: <span class="m">0</span>.0089111328125,
        <span class="s2">&quot;+&quot;</span>: <span class="m">0</span>.0654296875,
        <span class="s2">&quot;-&quot;</span>: <span class="m">0</span>.047607421875
    <span class="o">}</span>,
    <span class="s2">&quot;1&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;0|1&quot;</span>: <span class="m">0</span>.095458984375,
        <span class="s2">&quot;1|0&quot;</span>: <span class="m">0</span>.0115966796875,
        <span class="s2">&quot;+&quot;</span>: <span class="m">0</span>.1070556640625,
        <span class="s2">&quot;-&quot;</span>: <span class="m">0</span>.0838623046875
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Automating readout error mitigation with this decorator can be done in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s1">&#39;ibm:ibmq_johannesburg&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span><span class="mi">1024</span><span class="p">})</span>

<span class="c1"># Turn on readout error correction by decorating qpu</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getAcceleratorDecorator</span><span class="p">(</span><span class="s1">&#39;ro-error&#39;</span><span class="p">,</span> <span class="n">qpu</span><span class="p">)</span>

<span class="c1"># Now use qpu as your Accelerator...</span>
<span class="c1"># execution will be automatically readout</span>
<span class="c1"># error corrected</span>
</pre></div>
</div>
<p>Similarly, with a provided configuration file</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qcs:Aspen-2Q-A&quot;</span><span class="p">);</span>
<span class="n">qpu</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAcceleratorDecorator</span><span class="p">(</span><span class="s">&quot;ro-error&quot;</span><span class="p">,</span> <span class="n">qpu</span><span class="p">,</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;file&quot;</span><span class="p">,</span> <span class="s">&quot;probs.json&quot;</span><span class="p">)});</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/eclipse/xacc/blob/master/python/examples/readout_error_correction_aer.py">readout_error_correction_aer.py</a>
for a full example demonstrating the utility of the <code class="docutils literal notranslate"><span class="pre">ROErrorDecorator</span></code>.</p>
</div>
<div class="section" id="rdmpurificationdecorator">
<h3>RDMPurificationDecorator<a class="headerlink" href="#rdmpurificationdecorator" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="improvedsamplingdecorator">
<h3>ImprovedSamplingDecorator<a class="headerlink" href="#improvedsamplingdecorator" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="vqe-restart-decorator">
<h3>VQE Restart Decorator<a class="headerlink" href="#vqe-restart-decorator" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="ir-transformations">
<h2>IR Transformations<a class="headerlink" href="#ir-transformations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="circuitoptimizer">
<h3>CircuitOptimizer<a class="headerlink" href="#circuitoptimizer" title="Permalink to this headline">¶</a></h3>
<p>This <code class="docutils literal notranslate"><span class="pre">IRTransformation</span></code> of type <code class="docutils literal notranslate"><span class="pre">Optimization</span></code> will search the DAG representation
of a quantum circuit and remove all zero-rotations, hadamard and cnot pairs, and merge
adjacent common rotations (e.g. <code class="docutils literal notranslate"><span class="pre">Rx(.1)Rx(.1)</span> <span class="pre">-&gt;</span> <span class="pre">Rx(.2)</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a bell state program with too many cnots</span>
<span class="n">xacc</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">.compiler xasm</span>
<span class="s1">.circuit foo</span>
<span class="s1">.qbit q</span>
<span class="s1">H(q[0]);</span>
<span class="s1">CX(q[0], q[1]);</span>
<span class="s1">CX(q[0], q[1]);</span>
<span class="s1">CX(q[0], q[1]);</span>
<span class="s1">Measure(q[0]);</span>
<span class="s1">Measure(q[1]);</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getCompiled</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nInstructions</span><span class="p">())</span>

<span class="c1"># Run the circuit-optimizer IRTransformation, can pass</span>
<span class="c1"># accelerator (here None) and options (here empty dict())</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getIRTransformation</span><span class="p">(</span><span class="s1">&#39;circuit-optimizer&#39;</span><span class="p">)</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">{})</span>

<span class="c1"># should have 4 instructions, not 6</span>
<span class="k">assert</span><span class="p">(</span><span class="mi">4</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nInstructions</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="observables">
<h2>Observables<a class="headerlink" href="#observables" title="Permalink to this headline">¶</a></h2>
<div class="section" id="psi4-frozen-core">
<h3>Psi4 Frozen-Core<a class="headerlink" href="#psi4-frozen-core" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">psi4-frozen-core</span></code> observable generates an fermionic
observable using Psi4 and based on a user provided dictionary of options.
To use this Observable, ensure you have Psi4 installed under the same
<code class="docutils literal notranslate"><span class="pre">python3</span></code> used for the XACC Python API.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ git clone https://github.com/psi4/psi4 <span class="o">&amp;&amp;</span> <span class="nb">cd</span> psi4 <span class="o">&amp;&amp;</span> mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd</span> build
$ cmake .. -DPYTHON_EXECUTABLE<span class="o">=</span><span class="k">$(</span>which python3<span class="k">)</span> -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="k">$(</span>python3 -m site --user-site<span class="k">)</span>/psi4
$ make -j8 install
$ <span class="nb">export</span> <span class="nv">PYTHONPATH</span><span class="o">=</span><span class="k">$(</span>python3 -m site --user-site<span class="k">)</span>/psi4/lib:<span class="nv">$PYTHONPATH</span>
</pre></div>
</div>
<p>This observable type takes a dictionary of options describing the
molecular geometry (key <code class="docutils literal notranslate"><span class="pre">geometry</span></code>), the basis set (key <code class="docutils literal notranslate"><span class="pre">basis</span></code>),
and the list of frozen (key <code class="docutils literal notranslate"><span class="pre">frozen-spin-orbitals</span></code>) and active (key <code class="docutils literal notranslate"><span class="pre">active-spin-orbitals</span></code>) spin
orbital lists.</p>
<p>With Psi4 and XACC installed, you can use the frozen-core
Observable in the following way in python.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xacc</span>

<span class="n">geom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">0 1</span>
<span class="s1">Na  0.000000   0.0      0.0</span>
<span class="s1">H   0.0        0.0  1.914388</span>
<span class="s1">symmetry c1</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">fo</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>
<span class="n">ao</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">19</span><span class="p">]</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">.</span><span class="n">getObservable</span><span class="p">(</span><span class="s1">&#39;psi4-frozen-core&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">geom</span><span class="p">,</span>
                                    <span class="s1">&#39;frozen-spin-orbitals&#39;</span><span class="p">:</span> <span class="n">fo</span><span class="p">,</span>
                                    <span class="s1">&#39;active-spin-orbitals&#39;</span><span class="p">:</span> <span class="n">ao</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="circuit-generator">
<h2>Circuit Generator<a class="headerlink" href="#circuit-generator" title="Permalink to this headline">¶</a></h2>
<div class="section" id="aswap-ansatz-circuit">
<h3>ASWAP Ansatz Circuit<a class="headerlink" href="#aswap-ansatz-circuit" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ASWAP</span></code> circuit generator generates a state preparation (ansatz) circuit for the VQE Algorithm.
(See <a class="reference external" href="https://arxiv.org/abs/1904.10910">Gard, Bryan T., et al.</a>)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ASWAP</span></code> circuit generator requires the following input information:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 54%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm Parameter</p></th>
<th class="head"><p>Parameter Description</p></th>
<th class="head"><p>type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nbQubits</p></td>
<td><p>The number of qubits in the circuit.</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p>nbParticles</p></td>
<td><p>The number of particles.</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>timeReversalSymmetry</p></td>
<td><p>Do we have time-reversal symmetry?</p></td>
<td><p>boolean</p></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;xacc.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_observable.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;xacc_service.hpp&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">accelerator</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAccelerator</span><span class="p">(</span><span class="s">&quot;qpp&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">H_N_2</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">quantum</span><span class="o">::</span><span class="n">getObservable</span><span class="p">(</span>
      <span class="s">&quot;pauli&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;5.907 - 2.1433 X0X1 &quot;</span>
                          <span class="s">&quot;- 2.1433 Y0Y1&quot;</span>
                          <span class="s">&quot;+ .21829 Z0 - 6.125 Z1&quot;</span><span class="p">));</span>

  <span class="k">auto</span> <span class="n">optimizer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getOptimizer</span><span class="p">(</span><span class="s">&quot;nlopt&quot;</span><span class="p">);</span>
  <span class="c1">// Use the ASWAP circuit as the ansatz</span>
  <span class="n">xacc</span><span class="o">::</span><span class="n">qasm</span><span class="p">(</span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s"></span>
<span class="s">      .compiler xasm</span>
<span class="s">      .circuit deuteron_ansatz</span>
<span class="s">      .parameters t0</span>
<span class="s">      .qbit q</span>
<span class="s">      ASWAP(q, t0, {{&quot;nbQubits&quot;, 2}, {&quot;nbParticles&quot;, 1}});</span>
<span class="s">  </span><span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">ansatz</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getCompiled</span><span class="p">(</span><span class="s">&quot;deuteron_ansatz&quot;</span><span class="p">);</span>

  <span class="c1">// Get the VQE Algorithm and initialize it</span>
  <span class="k">auto</span> <span class="n">vqe</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">getAlgorithm</span><span class="p">(</span><span class="s">&quot;vqe&quot;</span><span class="p">);</span>
  <span class="n">vqe</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">({</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;ansatz&quot;</span><span class="p">,</span> <span class="n">ansatz</span><span class="p">),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;observable&quot;</span><span class="p">,</span> <span class="n">H_N_2</span><span class="p">),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;accelerator&quot;</span><span class="p">,</span> <span class="n">accelerator</span><span class="p">),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)});</span>

  <span class="c1">// Allocate some qubits and execute</span>
  <span class="k">auto</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">xacc</span><span class="o">::</span><span class="n">qalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">vqe</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="c1">// Expected result: -1.74886</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Energy: &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">)[</span><span class="s">&quot;opt-val&quot;</span><span class="p">].</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="advanced.html" class="btn btn-neutral float-right" title="Advanced" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basics.html" class="btn btn-neutral float-left" title="Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Alex McCaskey

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>