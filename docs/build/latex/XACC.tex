%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{XACC Documentation}
\date{Sep 07, 2017}
\release{0.0.1}
\author{Alex McCaskey}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Getting started with XACC}
\label{\detokenize{overview:getting-started-with-xacc}}\label{\detokenize{overview::doc}}\label{\detokenize{overview:welcome-to-xacc-s-documentation}}

\section{Overview}
\label{\detokenize{overview:overview}}
XACC is a programming framework for extreme-scale accelerator architectures that integrates alongside existing conventional classical applications. It is a pluggable framework for programming languages and accelerators developed for next-gen computing hardware architectures like quantum and neuromorphic computing. It lets computational scientists efficiently off-load classically intractable work to attached accelerators through a user-friendly kernel API. XACC makes post-exascale hybrid programming approachable for domain computational scientists.

The XACC programming model, and associated open-source reference implementation, follows the traditional co-processor model, akin to OpenCL or CUDA for GPUs, but takes into account the subtleties and complexities inherent to the interplay between classical and quantum hardware. XACC provides a high-level API that enables classical applications to offload computationally intractable work (represented as quantum kernels) to an attached quantum accelerator in a manner that is agnostic to the quantum programming language and the quantum hardware. This enables one to write quantum code once, and perform benchmarking, verification and validation, and performance studies for a set of virtual (simulators) or physical hardware.

To achieve this interoperability, XACC defines four primary abstractions or concepts: quantum kernels, intermediate representation, compilers, and accelerators. Quantum kernels are C-like functions that contain code intended for execution on the QPU. These kernels are compiled to the XACC intermediate representation (IR), an object model that is key for promoting the integration of a diverse set of languages and hardware. The IR provides four main forms for use by algorithm programmers: (1) an in-memory representation and API, (2) an on-disk persisted representation, (3) human-readable quantum assembly representation, and (4) a control flow graph or quantum circuit representation. This IR is produced by realizations of the XACC compiler concept, which delegates to the kernel language’s appropriate parser, compiler, and optimizer. Finally, XACC IR instances (and therefore programmed kernels) are executed by realizations of the Accelerator concept, which defines an interface for injecting physical or virtual quantum accelerators. Accelerators take this IR as input and delegate execution to vendor-supplied APIs for the QPU (or API for a simulator). The orchestration of these concepts enable an expressive API for quantum acceleration of classical applications.

XACC has support for a number of languages and physical and virtual hardware instances. XACC provides a Compiler realization that enables quantum kernel programming in the Scaffold programming language - an effort that came out of the IARPA QCS program. This compiler leverages the Clang/LLVM library extensions developed under that project that extend the LLVM IR with quantum gate operations. XACC extends this compiler with support for new constructs, like custom quantum functions and source-to-source translations (mapping Scaffold to other languages). XACC provides an Accelerator realization that enables execution of quantum kernels in any available language for both the Rigetti Quantum Virtual Machine (QVM, Forest API) and the physical two qubit (pyquillow) Rigetti QPU. These Accelerators map the XACC IR to Quil (the Rigetti low-level assembly language) and leverage an HTTP Rest client to post compiled quantum kernel code to the Rigetti QVM/QPU driver servers. XACC also has support for the D-Wave QPU, which demonstrates the wide applicability of this heterogeneous hybrid programming model across quantum computing models. XACC has Compiler and Accelerator realizations that enable minor graph embedding of binary optimization problems and execution on the D-Wave Qubist QPU driver server, respectively.


\section{XACC Plugin Infrastructure}
\label{\detokenize{overview:xacc-plugin-infrastructure}}
XACC relies on a project called \sphinxhref{http://github.com/cppmicroservices/cppmicroservices}{CppMicroServices} - a native C++ implementation of the OSGi specification that enables an extensible plugin infrastructure for compilers and accelerators. As such, installation of XACC provides the core infrastructure for describing Programs, Compilers, Accelerators, and IR. To enable support for various compilers and accelerators (like the Scaffold or Quil compilers, or the IBM or Rigetti QPUs) you must install the appropriate plugin (see \sphinxhref{plugins.html}{XACC Plugins}).


\section{XACC Development Team}
\label{\detokenize{overview:xacc-development-team}}
XACC is developed and maintained by:
\begin{itemize}
\item {} 
\sphinxhref{mailto:mccaskeyaj@ornl.gov}{Alex McCaskey}

\item {} 
\sphinxhref{mailto:humblets@ornl.gov}{Travis Humble}

\item {} 
\sphinxhref{mailto:dumitrescuef@ornl.gov}{Eugene Dumitrescu}

\item {} 
\sphinxhref{mailto:liakhdi@ornl.gov}{Dmitry Liakh}

\item {} 
\sphinxhref{mailto:mschen@vt.edu}{Mengsu Chen}

\end{itemize}


\section{Questions, Bug Reporting, and Issue Tracking}
\label{\detokenize{overview:questions-bug-reporting-and-issue-tracking}}
Questions, bug reporting and issue tracking are provided by GitHub. Please
report all bugs by creating a new issue. You can ask questions by creating a
new issue with the question tag.


\section{Publications and Presentations}
\label{\detokenize{overview:publications-and-presentations}}

\chapter{Installation}
\label{\detokenize{install:installation}}\label{\detokenize{install::doc}}
This section provide guidelines for installing XACC and its TPLs.


\section{Install third-party libraries}
\label{\detokenize{install:install-third-party-libraries}}
The following third party libraries (TPLs) are used by XACC:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Packages
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Dependency
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Version
\unskip}\relax \\
\hline
C++14 Compiler
&
Required
&
See below
\\
\hline
Boost
&
Required
&
1.59.0+
\\
\hline
MPI
&
Optional
&
N/A
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Note that you must have a C++14 compliant compiler.
For GCC, this means version 6.1+, for Clang, this means 3.4+.

These dependencies are relatively easy to install on popular operating
systems. Any of the following commands will work (showing with and without MPI):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} (macosx) brew install boost
\PYGZdl{} (macosx) brew install boost\PYGZhy{}mpi
\PYGZdl{} (fedora) dnf install boost\PYGZhy{}devel
\PYGZdl{} (fedora) dnf install boost\PYGZhy{}mpich\PYGZhy{}devel
\PYGZdl{} (fedora) dnf install boost\PYGZhy{}openmpi\PYGZhy{}devel
\PYGZdl{} (ubuntu) apt\PYGZhy{}get install libboost\PYGZhy{}all\PYGZhy{}dev \PYGZsh{} will install openmpi
\end{sphinxVerbatim}


\section{Build XACC}
\label{\detokenize{install:build-xacc}}
Clone the XACC repository:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/ornl\PYGZhy{}qci/xacc
\end{sphinxVerbatim}

XACC requires CMake 3.2+ to build. Run the following to
configure and build XACC:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd xacc \PYGZam{}\PYGZam{} mkdir build \PYGZam{}\PYGZam{} cd build
\PYGZdl{} cmake ..
\PYGZdl{} make install \PYGZsh{} can pass \PYGZhy{}jN for N = number of threads to use
\end{sphinxVerbatim}

This will install XACC to /usr/local/xacc
(Pass -DCMAKE\_INSTALL\_PREFIX=\$YOURINSTALLPATH to install it somewhere else).

Set your PATH variable to include the XACC bin directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} export PATH=/usr/local/xacc/bin:\PYGZdl{}PATH
\end{sphinxVerbatim}

Additionally, you could add this to your home directory’s .basrhc file (or equivalent).


\section{Installing XACC Plugins}
\label{\detokenize{install:installing-xacc-plugins}}
If you have successfully built XACC (see above)
then you can now run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}\PYGZhy{}help
\end{sphinxVerbatim}

This is a convenience python script to help download, build, and install
all currently supported XACC plugins. The execution syntax is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p PLUGIN\PYGZhy{}NAME
\end{sphinxVerbatim}

You can also run this script with multiple plugin names.

Let’s see how to use this script to install the
Rigetti, IBM, TNQVM, Scaffold, D-Wave, and Python plugins.

\begin{sphinxadmonition}{note}{Note:}
If you want support for the IBM, D-Wave, and Rigetti Accelerators, you must install
\sphinxhref{https://github.com/microsoft/cpprestsdk}{CppRestSDK} and OpenSSL. This
is required for these Accelerators to make remote HTTP Rest calls to their
respective server APIs. Here’s how to install these as binaries on various popular platforms:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} (macosx) brew install cpprestsdk
\PYGZdl{} (fedora) dnf install cpprest\PYGZhy{}devel openssl\PYGZhy{}devel
\PYGZdl{} (ubuntu) apt\PYGZhy{}get install libcpprest\PYGZhy{}dev libssl\PYGZhy{}dev
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Rigetti Support}
\label{\detokenize{install:rigetti-support}}
The \sphinxhref{https://github.com/ornl-qci/xacc-rigetti}{Rigetti Plugin} provides
support to XACC for compiling kernels writting in Quil, and executing programs
on the Rigetti QVM via a Rigetti Accelerator.

To install this plugin, run the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p xacc\PYGZhy{}rigetti
\end{sphinxVerbatim}

You have now installed the Rigetti plugin. It is located in \$XACC\_ROOT/lib/plugins/accelerator
and \$XACC\_ROOT/lib/plugins/compilers, where XACC\_ROOT is your XACC install prefix.


\subsection{IBM Support}
\label{\detokenize{install:ibm-support}}
The \sphinxhref{https://github.com/ornl-qci/xacc-ibm}{IBM Plugin} provides
support to XACC for executing programs
on the IBM Quantum Experience via the IBM Accelerator.

To install this plugin, run the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p xacc\PYGZhy{}ibm
\end{sphinxVerbatim}

You have now installed the IBM plugin. It is located in \$XACC\_ROOT/lib/plugins/accelerator,
where XACC\_ROOT is your XACC install prefix.


\subsection{TNQVM}
\label{\detokenize{install:tnqvm}}
The \sphinxhref{https://github.com/ornl-qci/tnqvm}{TNQVM Plugin} provides
support to XACC for executing programs
on the ORNL tensor network quantum virtual machine.

\begin{sphinxadmonition}{note}{Note:}
This Accelerator requires BLAS/LAPACK libraries to be installed.
Here’s how to install these as binaries on various popular platforms:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} (macosx) should already be there in Accelerate Framework, if not
\PYGZdl{} (macosx) brew install openblas lapack
\PYGZdl{} (fedora) dnf install blas\PYGZhy{}devel lapack\PYGZhy{}devel
\PYGZdl{} (ubuntu) apt\PYGZhy{}get install libblas\PYGZhy{}dev liblapack\PYGZhy{}dev
\end{sphinxVerbatim}
\end{sphinxadmonition}

To install this plugin, run the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p tnqvm
\end{sphinxVerbatim}

You have now installed the TNQVM plugin. It is located in \$XACC\_ROOT/lib/plugins/accelerator,
where XACC\_ROOT is your XACC install prefix.


\subsection{Scaffold Support}
\label{\detokenize{install:scaffold-support}}
\begin{sphinxadmonition}{note}{Note:}
Due to issues getting \sphinxhref{https://github.com/ornl-qci/ScaffCC}{ScaffCC} to link correctly with RTTI on Mac OS X, we do not have a binary package installer for Mac OS X. We are open to PRs on this if you can help.
\end{sphinxadmonition}

To use the \sphinxhref{https://github.com/ornl-qci/tnqvm}{Scaffold Plugin} you must have our fork of
Scaffold installed as a binary package. We have builds for Fedora 25/26 and Ubuntu 16.04/17.04. To
install

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} (fedora) dnf install https://github.com/ORNL\PYGZhy{}QCI/ScaffCC/releases/download/v2.0/scaffold\PYGZhy{}2.0\PYGZhy{}1.fc25.x86\PYGZus{}64.rpm (REPLACE 25 with 26 if on FC26)
\PYGZdl{} (ubuntu) wget https://github.com/ORNL\PYGZhy{}QCI/ScaffCC/releases/download/v2.0/scaffold\PYGZus{}2.0\PYGZus{}amd64.deb
\PYGZdl{} (ubuntu) apt\PYGZhy{}get install \PYGZhy{}y \PYGZdl{}(dpkg \PYGZhy{}\PYGZhy{}info scaffold\PYGZus{}2.0\PYGZus{}amd64.deb \textbar{} grep Depends \textbar{} sed \PYGZdq{}s/.*ends:\PYGZbs{} //\PYGZdq{} \textbar{} sed \PYGZsq{}s/,//g\PYGZsq{})
\PYGZdl{} (ubuntu) dpkg \PYGZhy{}i scaffold\PYGZus{}2.0\PYGZus{}amd64.deb
\end{sphinxVerbatim}

To install this plugin, run the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p xacc\PYGZhy{}scaffold
\end{sphinxVerbatim}

You have now installed the Scaffold plugin. It is located in \$XACC\_ROOT/lib/plugins/compilers,
where XACC\_ROOT is your XACC install prefix.


\subsection{D-Wave Support}
\label{\detokenize{install:d-wave-support}}
The \sphinxhref{https://github.com/ornl-qci/xacc-dwave}{D-Wave Plugin} provides
support to XACC for executing programs
on the D-Wave QPU via the D-Wave Accelerator.

To install this plugin, run the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p xacc\PYGZhy{}dwave
\end{sphinxVerbatim}

You have now installed the D-Wave plugin. It is located in \$XACC\_ROOT/lib/plugins/accelerator,
where XACC\_ROOT is your XACC install prefix.

Furthermore, XACC has extensibility built in for minor graph embedding
algorithms. We currently have one supported embedding algorithm, a wrapper around
the D-Wave SAPI Cai, Macready, Roi algorithm. In order to install this as a plugin,
run the following

\begin{sphinxadmonition}{note}{Note:}
The following embedding algorithm needs to leverage the proprietary
D-Wave SAPI header file and associated shared library: dwave\_sapi.h and libdwave\_sapi.so.
In order for the installation below to work, place dwave\_sapi.h in /usr/local/include/
and libdwave\_sapi.so in /usr/local/lib/
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p xacc\PYGZhy{}dwave\PYGZhy{}sapi\PYGZhy{}embedding
\end{sphinxVerbatim}

You have now installed the D-Wave plugin. It is located in \$XACC\_ROOT/lib/plugins/accelerator
and \$XACC\_ROOT/lib/plugins/compilers, where XACC\_ROOT is your XACC install prefix.


\subsection{Python Bindings}
\label{\detokenize{install:python-bindings}}
The \sphinxhref{https://github.com/ornl-qci/xacc-python}{Python Plugin} provides
Python language bindings to XACC through the \sphinxhref{https://github.com/pybind/pybind11}{pybind11} project.

\begin{sphinxadmonition}{note}{Note:}
This plugin requires Python 2.7+ development headers/library.
Here’s how to install these on various popular platforms:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} (macosx) brew install python
\PYGZdl{} (fedora) dnf install python\PYGZhy{}devel
\PYGZdl{} (ubuntu) apt\PYGZhy{}get install python\PYGZhy{}dev
\end{sphinxVerbatim}
\end{sphinxadmonition}

To install this plugin, run the following

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xacc\PYGZhy{}install\PYGZhy{}plugins.py \PYGZhy{}p xacc\PYGZhy{}python
\end{sphinxVerbatim}

You have now installed the Python plugin. It is located in \$XACC\_ROOT/lib/python,
where XACC\_ROOT is your XACC install prefix.

In order to use this installation, you must update your PYTHONPATH environment variable

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} export PYTHONPATH=\PYGZdl{}XACC\PYGZus{}ROOT/lib/python:\PYGZdl{}PYTHONPATH
\end{sphinxVerbatim}

We recommend placing this command in your home directory’s .bashrc file (or equivalent).


\section{XACC and Spack}
\label{\detokenize{install:xacc-and-spack}}
You can build XACC and its dependencies with the \sphinxhref{https://github.com/llnl/spack}{Spack} package manager.

To configure your available system compilers run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} spack compilers
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If you run ‘spack config get compilers’ and your desired
compiler has fc and f77 set to Null or None, then the
install will not work if you are including MPI support.
If this is the case, it usually
works to run ‘spack config edit compilers’ and
manually replace Null with /path/to/your/gfortran
\end{sphinxadmonition}

We will rely on the environment-modules package to load/unload
installed Spack modules. If you don’t have this installed
(you can check by running ‘module avail’) install with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} spack install environment\PYGZhy{}modules
\end{sphinxVerbatim}

Add the following to your \textasciitilde{}/.bashrc (or equivalent)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
. \PYGZdl{}SPACK\PYGZus{}ROOT/share/spack/setup\PYGZhy{}env.sh
source \PYGZdl{}(spack location \PYGZhy{}i environment\PYGZhy{}modules)/Modules/init/bash
\end{sphinxVerbatim}

If you do not have a C++14 compliant compiler, you can
install one with Spack, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} spack install gcc@7.2.0 \PYGZsh{} this will take awhile...
\PYGZdl{} spack load gcc
\PYGZdl{} spack compiler find
\end{sphinxVerbatim}

Now install the dependencies with your specified C++14 compiler (mine
will be gcc 7.2.0)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} (with MPI support) spack install boost+mpi+graph \PYGZca{}mpich \PYGZpc{}gcc@7.2.0
\PYGZdl{} (without MPI support) spack install boost+graph \PYGZpc{}gcc@7.2.0
\end{sphinxVerbatim}

XACC has not yet been accepted into the Spack (we will soon issue a PR
to get it shipped as part of Spack). So in order to install it with Spack
we have to download our custom package recipe from the XACC repository:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZdl{}SPACK\PYGZus{}ROOT/var/spack/repos/builtin/packages/ \PYGZam{}\PYGZam{} mkdir xacc
\PYGZdl{} cd xacc \PYGZam{}\PYGZam{} wget https://github.com/ORNL\PYGZhy{}QCI/xacc/raw/master/cmake/spack/xacc/package.py .
\end{sphinxVerbatim}

Now we can run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} spack install xacc \PYGZpc{}gcc@7.2.0
\end{sphinxVerbatim}

Once all these are installed, load them as environment modules
so they are available for the XACC build:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} spack load boost
\end{sphinxVerbatim}


\chapter{XACC API}
\label{\detokenize{api:xacc-api}}\label{\detokenize{api::doc}}

\section{Kernels}
\label{\detokenize{api:kernels}}

\section{Compilers}
\label{\detokenize{api:compilers}}

\section{Intermediate Representation}
\label{\detokenize{api:intermediate-representation}}

\section{IR Transformations}
\label{\detokenize{api:ir-transformations}}

\section{Accelerators}
\label{\detokenize{api:accelerators}}

\section{Programs}
\label{\detokenize{api:programs}}

\chapter{XACC Plugins}
\label{\detokenize{plugins:xacc-plugins}}\label{\detokenize{plugins::doc}}

\section{Rigetti}
\label{\detokenize{plugins:rigetti}}
Rigetti Computing, Inc (\sphinxurl{rigetti.com}) is a recently founded startup that is focused on
developing quantum computing hardware and software and bring it to market.
They are working to build a cloud quantum computing platform for AI and
computational chemistry. They currently have a QVM simulation server
that can be accessed via a REST API with a private API key. Rigetti has
also done great work as of late in providing open source programming tools for
interfacing with their QVM - specifically, the PyQuil python framework
\sphinxhref{https://github.com/rigetticomputing/pyquil}{PyQuil}.

Recently, the ORNL QCI \sphinxhref{http://quantum.ornl.gov}{(quantum.ornl.gov)}, the XACC project,
and the Software and Applications Team from Rigetti have begun collaborating in
an effort to expose the Rigetti QVM server and programming tools to XACC and its user
community. This article describes the results of that work - specifically, a
new XACC Accelerator implementation that executes quantum kernels on the
Rigetti QVM server. For a more hands-on tutorial on how to use XACC and the Rigetti
Accelerator, check out \sphinxhref{tutorials.html\#RigettiQVMTutorial}{Rigetti Tutorial}).


\subsection{RigettiAccelerator}
\label{\detokenize{plugins:rigettiaccelerator}}
The RigettiAccelerator is an implementation or realization of the pluggable
XACC Accelerator interface. The RigettAccelerator class architecture diagram is
shown in Figure 1. The RigettiAccelerator’s implementation of the Accelerator::execute() method
is charged with two primary tasks: (1) the translation of the XACC IR to an equivalent
Quil string, and (2) constructing and executing an
appropriate HTTPS Post on the Rigetti QVM server. The only remaining
thing to do once those two tasks are complete is to processes the resultant response from the server.

\noindent\sphinxincludegraphics{{../../assets/rigetti-acc-arch}.png}


\subsection{Mapping XACC IR to Quil}
\label{\detokenize{plugins:mapping-xacc-ir-to-quil}}
Basically,
at its core, the XACC IR provides a tree-like, in-memory representation and API for a
compiled quantum kernel. The leaves of this tree are XACC Instructions and the nodes
of the tree are XACC Functions, which are composed of further child Instructions. The
XACC Quantum IR implementation provides a number of standard gate Instruction implementations
(Hadamard, CNOT, rotations, etc…) These serve as the leaves of the IR tree. These
instruction implementations know nothing of the Quil intermediate language and it would be tedious
and a poor design decision to to update the entire XACC Quantum IR package (we would have to do the
same for any and all current and future low-level languages). So XACC employs a common
software engineering design pattern to enable this XACC IR to Quil mapping: the
visitor pattern, which provides a mechansim for adding new operations to an
existing object without modifying the design of that object (\sphinxhref{https://en.wikipedia.org/wiki/Visitor\_pattern}{Visitor Pattern}). For each derived gate Instruction, a Visitor class implements a
corresponding \sphinxcode{{}`visit{}`} method (\sphinxcode{{}`visit(Hadamard\& h){}`}, etc…). All gate instructions have the
ability to accept an incoming Visitor, and upon doing so, invoke the \sphinxcode{{}`visit{}`} method that
corresponds to their type, thus giving the Visitor type information for the Gate Instruction.
Therefore, mapping to Quil simply involves walking the IR tree, and telling each Instruction to
accept the visitor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{auto} \PYG{n}{visitor} \PYG{o}{=} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{QuilVisitor}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{InstructionIterator} \PYG{n}{it}\PYG{p}{(}\PYG{n}{kernel}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{it}\PYG{o}{.}\PYG{n}{hasNext}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{o}{/}\PYG{o}{/} \PYG{n}{Get} \PYG{n}{the} \PYG{n+nb}{next} \PYG{n}{node} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{tree}
   \PYG{n}{auto} \PYG{n}{nextInst} \PYG{o}{=} \PYG{n}{it}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{nextInst}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isEnabled}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{nextInst}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accept}\PYG{p}{(}\PYG{n}{visitor}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{auto} \PYG{n}{quilStr} \PYG{o}{=} \PYG{n}{visitor}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getQuilString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The visitor implementation is known as the QuilVisitor, and its visit methods look like this (Hadamard for example):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{visit}\PYG{p}{(}\PYG{n}{Hadamard}\PYG{o}{\PYGZam{}} \PYG{n}{h}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{quilStr} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{h}\PYG{o}{.}\PYG{n}{bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

or for a more complicated gate Instruction:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{visit}\PYG{p}{(}\PYG{n}{ConditionalFunction}\PYG{o}{\PYGZam{}} \PYG{n}{c}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{auto} \PYG{n}{visitor} \PYG{o}{=} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{make\PYGZus{}shared}\PYG{o}{\PYGZlt{}}\PYG{n}{QuilVisitor}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{auto} \PYG{n}{classicalBitIdx} \PYG{o}{=} \PYG{n}{qubitToClassicalBitIndex}\PYG{p}{[}\PYG{n}{c}\PYG{o}{.}\PYG{n}{getConditionalQubit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{populated} \PYG{o+ow}{in} \PYG{n}{visit}\PYG{p}{(}\PYG{n}{Measure}\PYG{p}{)}
   \PYG{n}{quilStr} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{JUMP\PYGZhy{}UNLESS @}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n}{getName}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ [}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{classicalBitIdx}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{n}{auto} \PYG{n}{inst} \PYG{p}{:} \PYG{n}{c}\PYG{o}{.}\PYG{n}{getInstructions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{n}{inst}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{accept}\PYG{p}{(}\PYG{n}{visitor}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
  \PYG{n}{quilStr} \PYG{o}{+}\PYG{o}{=} \PYG{n}{visitor}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getQuilString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{quilStr} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LABEL @}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{c}\PYG{o}{.}\PYG{n}{getName}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

After walking the IR tree, the Quil representation is produced with a call to getQuilString().


\subsection{Executing Quil code on Rigetti QVM}
\label{\detokenize{plugins:executing-quil-code-on-rigetti-qvm}}
With the XACC IR mapped to Quil, the RigettiAccelerator is ready to execute
on the Rigetti QVM. The main task here is to construct the proper JSON payload string
that contains information about the type of the execution, the classical memory address
indices, and the Quil instructions string. The types of execution that the QVM allows are
multishot, multishot-measure, wavefunction, and expectation. In this work, we have primarily focused
on the multishot method. If the execution type is
multishot, then we can provide a further JSON key that is an integer that gives the
number of executions of the Quil code to run.


\section{IBM}
\label{\detokenize{plugins:ibm}}

\section{D-Wave}
\label{\detokenize{plugins:d-wave}}

\section{Scaffold}
\label{\detokenize{plugins:scaffold}}

\section{TNQVM}
\label{\detokenize{plugins:tnqvm}}
Python
—— -


\chapter{XACC Tutorials}
\label{\detokenize{tutorials:xacc-tutorials}}\label{\detokenize{tutorials::doc}}
First off, make sure you have successfully built XACC (see \sphinxhref{install.html}{XACC Install}).


\section{Rigetti QVM Tutorial}
\label{\detokenize{tutorials:rigetti-qvm-tutorial}}
Create a new directory called test-xacc-rigetti and cd into it. Let’s now create a
test-xacc-rigetti.cpp file and get it started with the following boilerplate code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}include \PYGZdq{}XACC.hpp\PYGZdq{}}

\PYG{n+nb}{int} \PYG{n}{main}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{n}{char}\PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)} \PYG{p}{\PYGZob{}}

   \PYG{o}{/}\PYG{o}{/} \PYG{n}{Initialize} \PYG{n}{XACC} \PYG{o}{\PYGZhy{}} \PYG{n}{find} \PYG{n+nb}{all} \PYG{n}{available}
   \PYG{o}{/}\PYG{o}{/} \PYG{n}{compilers} \PYG{o+ow}{and} \PYG{n}{accelerators}\PYG{p}{,} \PYG{n}{parse} \PYG{n}{command} \PYG{n}{line}\PYG{o}{.}
   \PYG{n}{xacc}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Initialize}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}

   \PYG{o}{/}\PYG{o}{/} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Code} \PYG{n}{to} \PYG{n}{come} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

   \PYG{o}{/}\PYG{o}{/} \PYG{n}{Finalize} \PYG{n}{the} \PYG{n}{framework}\PYG{o}{.}
   \PYG{n}{xacc}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Building this code is straightforward with CMake. Create a CMakeLists.txt file in the same
directory as the test-xacc-rigetti.cpp file, and add the following to it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} Start a CMake project
project(test\PYGZhy{}xacc\PYGZhy{}rigetti CXX)

\PYGZsh{} Set the minimum version to 3.2
cmake\PYGZus{}minimum\PYGZus{}required(VERSION 3.2)

\PYGZsh{} Find XACC
find\PYGZus{}package(XACC REQUIRED)

\PYGZsh{} Find Boost
find\PYGZus{}package(Boost COMPONENTS system program\PYGZus{}options filesystem chrono thread REQUIRED)

\PYGZsh{} Include all XACC Include Directories
include\PYGZus{}directories(\PYGZdl{}\PYGZob{}XACC\PYGZus{}INCLUDE\PYGZus{}DIRS\PYGZcb{})

\PYGZsh{} Link to the XACC Library Directory,
link\PYGZus{}directories(\PYGZdl{}\PYGZob{}XACC\PYGZus{}LIBRARY\PYGZus{}DIR\PYGZcb{})

\PYGZsh{} Create the executabe
add\PYGZus{}executable(test\PYGZhy{}xacc\PYGZhy{}rigetti test\PYGZhy{}xacc\PYGZhy{}rigetti.cpp)

\PYGZsh{} Like the necessary libaries
target\PYGZus{}link\PYGZus{}libraries(test\PYGZhy{}xacc\PYGZhy{}rigetti \PYGZdl{}\PYGZob{}XACC\PYGZus{}LIBRARIES\PYGZcb{} dl pthread)
\end{sphinxVerbatim}

Now from within the test-xacc-rigetti directory, run the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mkdir build
\PYGZdl{} cd build
\PYGZdl{} cmake ..
\PYGZdl{} make
\end{sphinxVerbatim}

This will build test-xacc-rigetti.cpp and provide you with a test-xacc-rigetti executable. Run that
executable to ensure that your build worked (you should see the following output):
.. code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make
\PYGZdl{} ./test\PYGZhy{}xacc\PYGZhy{}rigetti
[2017\PYGZhy{}06\PYGZhy{}20 16:14:07.076] [xacc\PYGZhy{}console] [info] [xacc] Initializing XACC Framework
[2017\PYGZhy{}06\PYGZhy{}20 16:14:07.091] [xacc\PYGZhy{}console] [info] [xacc::compiler] XACC has 1 Compilers available.
[2017\PYGZhy{}06\PYGZhy{}20 16:14:07.091] [xacc\PYGZhy{}console] [info] [xacc::accelerator] XACC has 1 Accelerators available.
[2017\PYGZhy{}06\PYGZhy{}20 16:14:07.091] [xacc\PYGZhy{}console] [info]
[xacc] XACC Finalizing
[xacc::compiler] Cleaning up Compiler Registry.
[xacc::accelerator] Cleaning up Accelerator Registry.
\end{sphinxVerbatim}

Now that we have our build and initial boilerplate code setup, let’s actually write some quantum code, specifically
teleporting the state of one qubit to another. Following the XACC.hpp include statement at the top of the file,
add the following quantum kernel declaration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{const} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string} \PYG{n}{src}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}qpu\PYGZus{}\PYGZus{} teleport (qbit qreg) }\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   cbit creg[3];}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   // Init qubit 0 to 1}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   X(qreg[0]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   // Now teleport...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   H(qreg[1]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   CNOT(qreg[1],qreg[2]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   CNOT(qreg[0],qreg[1]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   H(qreg[0]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   creg[0] = MeasZ(qreg[0]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   creg[1] = MeasZ(qreg[1]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   if (creg[0] == 1) Z(qreg[2]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   if (creg[1] == 1) X(qreg[2]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   // Check that 3rd qubit is a 1}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   creg[2] = MeasZ(qreg[2]);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now we are ready to build and execute this kernel using the XACC Runtime API. After the call
to xacc::Initialize, add the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
// Create a reference to the Rigetti
// QPU at api.rigetti.com/qvm
auto qpu = xacc::getAccelerator(\PYGZdq{}rigetti\PYGZdq{});

// Allocate a register of 3 qubits
auto qubitReg = qpu\PYGZhy{}\PYGZgt{}createBuffer(\PYGZdq{}qreg\PYGZdq{}, 3);

// Create a Program
xacc::Program program(qpu, src);

// Request the quantum kernel representing
// the above source code
auto teleport = program.getKernel(\PYGZdq{}teleport\PYGZdq{});

// Execute!
teleport(qubitReg);
\end{sphinxVerbatim}

The code above starts by getting a reference to the RigettiAccelerator.
With that reference, we then allocate a register of qubits
to operate the teleport kernel on. Next, we instantiate an XACC Program instance, which keeps track of the
desired Accelerator and the source code to be compiled. The Program instance orchestrates the compilation of the
quantum kernel to produce the XACC intermediate representation, and then handles the creation of an
executable classical kernel function that offloads the compiled quantum code to the specified Accelerator.
Finally, the user requests a reference to the executable kernel functor, and executes it on the
provided register of qubits.

The total test-xacc-rigetti.cpp file should look like this:
.. code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZdq{}XACC.hpp\PYGZdq{}

// Quantum Kernel executing teleportation of
// qubit state to another.
const std::string src(\PYGZdq{}\PYGZus{}\PYGZus{}qpu\PYGZus{}\PYGZus{} teleport (qbit qreg) \PYGZob{}\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   cbit creg[3];\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   // Init qubit 0 to 1\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   X(qreg[0]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   // Now teleport...\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   H(qreg[1]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   CNOT(qreg[1],qreg[2]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   CNOT(qreg[0],qreg[1]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   H(qreg[0]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   creg[0] = MeasZ(qreg[0]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   creg[1] = MeasZ(qreg[1]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   if (creg[0] == 1) Z(qreg[2]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   if (creg[1] == 1) X(qreg[2]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   // Check that 3rd qubit is a 1\PYGZbs{}n\PYGZdq{}
\PYGZdq{}   creg[2] = MeasZ(qreg[2]);\PYGZbs{}n\PYGZdq{}
\PYGZdq{}\PYGZcb{}\PYGZbs{}n\PYGZdq{});

int main (int argc, char** argv) \PYGZob{}

   // Initialize the XACC Framework
   xacc::Initialize(argc, argv);

   // Create a reference to the Rigetti
   // QPU at api.rigetti.com/qvm
   auto qpu = xacc::getAccelerator(\PYGZdq{}rigetti\PYGZdq{});

   // Allocate a register of 3 qubits
   auto qubitReg = qpu\PYGZhy{}\PYGZgt{}createBuffer(\PYGZdq{}qreg\PYGZdq{}, 3);

   // Create a Program
   xacc::Program program(qpu, src);

   // Request the quantum kernel representing
   // the above source code
   auto teleport = program.getKernel(\PYGZdq{}teleport\PYGZdq{});

   // Execute!
   teleport(qubitReg);

   // Finalize the XACC Framework
   xacc::Finalize();

   return 0;
\PYGZcb{}
\end{sphinxVerbatim}

Now, to build simple run:
.. code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd test\PYGZhy{}xacc\PYGZhy{}rigetti/build
\PYGZdl{} make
\end{sphinxVerbatim}

To execute this code on the Rigetti QVM, you must provide your API key. You can do this
the same way you do with PyQuil (in your \$HOME/.pyquil\_config file, or in the \$PYQUIL\_CONFIG
environment variable). You can also pass your API key to the XACC executable through the
\textendash{}rigetti-api-key command line argument:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test\PYGZhy{}xacc\PYGZhy{}rigetti \PYGZhy{}\PYGZhy{}rigetti\PYGZhy{}api\PYGZhy{}key KEY
[2017\PYGZhy{}06\PYGZhy{}20 17:43:38.744] [xacc\PYGZhy{}console] [info] [xacc] Initializing XACC Framework
[2017\PYGZhy{}06\PYGZhy{}20 17:43:38.760] [xacc\PYGZhy{}console] [info] [xacc::compiler] XACC has 3 Compilers available.
[2017\PYGZhy{}06\PYGZhy{}20 17:43:38.760] [xacc\PYGZhy{}console] [info] [xacc::accelerator] XACC has 2 Accelerators available.
[2017\PYGZhy{}06\PYGZhy{}20 17:43:38.766] [xacc\PYGZhy{}console] [info] Executing Scaffold compiler.
[2017\PYGZhy{}06\PYGZhy{}20 17:43:38.770] [xacc\PYGZhy{}console] [info] Rigetti Json Payload = \PYGZob{} \PYGZdq{}type\PYGZdq{} : \PYGZdq{}multishot\PYGZdq{}, \PYGZdq{}addresses\PYGZdq{} : [0, 1, 2], \PYGZdq{}quil\PYGZhy{}instructions\PYGZdq{} : \PYGZdq{}X 0\PYGZbs{}nH 1\PYGZbs{}nCNOT 1 2\PYGZbs{}nCNOT 0 1\PYGZbs{}nH 0\PYGZbs{}nMEASURE 0 [0]\PYGZbs{}nMEASURE 1 [1]\PYGZbs{}nJUMP\PYGZhy{}UNLESS @conditional\PYGZus{}0 [0]\PYGZbs{}nZ 2\PYGZbs{}nLABEL @conditional\PYGZus{}0\PYGZbs{}nJUMP\PYGZhy{}UNLESS @conditional\PYGZus{}1 [1]\PYGZbs{}nX 2\PYGZbs{}nLABEL @conditional\PYGZus{}1\PYGZbs{}nMEASURE 2 [2]\PYGZbs{}n\PYGZdq{}, \PYGZdq{}trials\PYGZdq{} : 10 \PYGZcb{}
[2017\PYGZhy{}06\PYGZhy{}20 17:43:40.439] [xacc\PYGZhy{}console] [info] Successful HTTP Post to Rigetti.
[2017\PYGZhy{}06\PYGZhy{}20 17:43:40.439] [xacc\PYGZhy{}console] [info] Rigetti QVM Response:
[[0,1,1],[1,1,1],[1,1,1],[0,1,1],[1,0,1],[1,1,1],[0,1,1],[0,1,1],[0,0,1],[0,0,1]]
[2017\PYGZhy{}06\PYGZhy{}20 17:43:40.439] [xacc\PYGZhy{}console] [info]
[xacc] XACC Finalizing
[xacc::compiler] Cleaning up Compiler Registry.
[xacc::accelerator] Cleaning up Accelerator Registry.
\end{sphinxVerbatim}

You should see the console text printed above.

You can also tailor the number of executions that occur for the multishot execution type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./test\PYGZhy{}xacc\PYGZhy{}rigetti \PYGZhy{}\PYGZhy{}rigetti\PYGZhy{}trials 1000
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.285] [xacc\PYGZhy{}console] [info] [xacc] Initializing XACC Framework
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.301] [xacc\PYGZhy{}console] [info] [xacc::compiler] XACC has 3 Compilers available.
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.301] [xacc\PYGZhy{}console] [info] [xacc::accelerator] XACC has 2 Accelerators available.
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.307] [xacc\PYGZhy{}console] [info] Executing Scaffold compiler.
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.310] [xacc\PYGZhy{}console] [info] Rigetti Json Payload = \PYGZob{} \PYGZdq{}type\PYGZdq{} : \PYGZdq{}multishot\PYGZdq{}, \PYGZdq{}addresses\PYGZdq{} : [0, 1, 2], \PYGZdq{}quil\PYGZhy{}instructions\PYGZdq{} : \PYGZdq{}X 0\PYGZbs{}nH 1\PYGZbs{}nCNOT 1 2\PYGZbs{}nCNOT 0 1\PYGZbs{}nH 0\PYGZbs{}nMEASURE 0 [0]\PYGZbs{}nMEASURE 1 [1]\PYGZbs{}nJUMP\PYGZhy{}UNLESS @conditional\PYGZus{}0 [0]\PYGZbs{}nZ 2\PYGZbs{}nLABEL @conditional\PYGZus{}0\PYGZbs{}nJUMP\PYGZhy{}UNLESS @conditional\PYGZus{}1 [1]\PYGZbs{}nX 2\PYGZbs{}nLABEL @conditional\PYGZus{}1\PYGZbs{}nMEASURE 2 [2]\PYGZbs{}n\PYGZdq{}, \PYGZdq{}trials\PYGZdq{} : 100 \PYGZcb{}
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.909] [xacc\PYGZhy{}console] [info] Successful HTTP Post to Rigetti.
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.909] [xacc\PYGZhy{}console] [info] Rigetti QVM Response:
[[1,0,1],[0,0,1],[1,1,1],[0,1,1],[1,0,1],[0,1,1],[0,0,1],[1,1,1],[1,0,1],[1,0,1],[0,0,1],[1,0,1],[1,1,1],[0,1,1],[0,0,1],[1,1,1],[1,0,1],[1,1,1],[0,0,1],[1,1,1],[1,0,1],[0,0,1],[0,0,1],[1,0,1],[0,1,1],[0,0,1],[1,1,1],[0,0,1],[0,1,1],[1,1,1],[1,0,1],[1,0,1],[0,1,1],[0,1,1],[1,1,1],[1,1,1],[1,1,1],[0,1,1],[1,1,1],[1,0,1],[1,0,1],[1,1,1],[1,1,1],[0,0,1],[1,1,1],[0,0,1],[1,0,1],[1,1,1],[1,0,1],[1,1,1],[0,1,1],[0,1,1],[1,0,1],[0,0,1],[1,1,1],[0,1,1],[0,1,1],[1,1,1],[1,0,1],[1,1,1],[0,0,1],[0,0,1],[1,0,1],[0,1,1],[0,0,1],[0,1,1],[1,0,1],[0,1,1],[1,0,1],[0,0,1],[1,0,1],[1,1,1],[1,0,1],[1,1,1],[0,0,1],[0,1,1],[1,0,1],[1,1,1],[1,1,1],[0,1,1],[1,0,1],[1,1,1],[0,1,1],[1,0,1],[1,0,1],[0,0,1],[1,0,1],[0,0,1],[0,0,1],[1,0,1],[1,1,1],[0,1,1],[0,1,1],[0,1,1],[1,0,1],[1,1,1],[1,1,1],[0,1,1],[0,1,1],[0,1,1]]
[2017\PYGZhy{}06\PYGZhy{}20 17:50:57.910] [xacc\PYGZhy{}console] [info]
[xacc] XACC Finalizing
[xacc::compiler] Cleaning up Compiler Registry.
[xacc::accelerator] Cleaning up Accelerator Registry.
\end{sphinxVerbatim}

Note above we let XACC find the API Key in the standard .pyquil\_config file.


\section{XACC Python Bindings Tutorial}
\label{\detokenize{tutorials:xacc-python-bindings-tutorial}}

\section{PyQuil-XACC Integration}
\label{\detokenize{tutorials:pyquil-xacc-integration}}

\section{XACC D-Wave Markowitz Financial Modeling}
\label{\detokenize{tutorials:xacc-d-wave-markowitz-financial-modeling}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}